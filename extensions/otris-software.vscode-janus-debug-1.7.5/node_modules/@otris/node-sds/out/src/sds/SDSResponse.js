"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SDSResponse = void 0;
const assert = require("assert");
const network_1 = require("../network");
const SDSMessage_1 = require("./SDSMessage");
/** The first index a parameter can occur in a valid sds message */
const FIRST_PARAM_INDEX = 13;
/** Map with the paramter names (key = value of the enum, value = Name of the enum property) */
const parameterNamesMap = (() => {
    const parameterNamesKeys = Object.keys(SDSMessage_1.ParameterNames);
    const _parameterNamesMap = new Map();
    for (let i = parameterNamesKeys.length / 2; i < parameterNamesKeys.length; i++) {
        _parameterNamesMap.set(parseInt(parameterNamesKeys[i - parameterNamesKeys.length / 2], 10), parameterNamesKeys[i]);
    }
    return _parameterNamesMap;
})();
/** Map with the paramter names (key = value of the enum, value = Name of the enum property) */
const typesMap = (() => {
    const typesKeys = Object.keys(SDSMessage_1.Types);
    const _typesMap = new Map();
    for (let i = typesKeys.length / 2; i < typesKeys.length; i++) {
        _typesMap.set(parseInt(typesKeys[i - typesKeys.length / 2], 10), typesKeys[i]);
    }
    return _typesMap;
})();
class SDSResponse extends SDSMessage_1.SDSMessage {
    /**
     * Parses the response from the JANUS-server and provides some operation to read the message
     * @param buffer Response buffer returned from the JANUS-server
     */
    constructor(buffer, parseBuffer = true) {
        super(buffer);
        // build the header
        this.header = {
            messageLength: { position: 0, value: this.bufferedLength },
            oId: { position: 4, value: this.getOIDFromBuffer() },
            operation: { position: 12, value: this.buffer[12] },
        };
        // create a map of parameters. It's easier for debugging and allows us to return requested parameters by
        // using the map
        if (parseBuffer) {
            this.parameters = this.parseResponseParameters();
        }
        else {
            this.parameters = new Map();
        }
    }
    /**
     * Returns the object id the response belongs to
     * @returns The object id the response belongs to
     */
    get oId() {
        return this.header.oId.value;
    }
    /**
     * Returns the operation which should be executed
     * @returns Operation which should be executed
     */
    get operation() {
        return this.header.operation.value;
    }
    /**
     * Extracts the passed parameter from the response
     * @param parameterName Name of the parameter
     * @returns The value of the passed parameter
     */
    getParameter(parameterName) {
        const responseParameter = this.parameters.get(parameterName);
        if (responseParameter) {
            return responseParameter.value;
        }
        else {
            throw new Error(`Unknown paramter: ${parameterName}.\r\nParameters: ${JSON.stringify([...this.parameters.entries()])}`);
        }
    }
    /**
     * Determines if a response contains a given parameter
     * @param parameterName Name of the paramter
     * @returns True if the request contains the passed parameter, otherwise false
     */
    hasParameter(parameterName) {
        return this.parameters.has(parameterName);
    }
    /**
     * Determines if the response is a ACK
     * @returns true, if the response is an ACK, otherwise false
     */
    isACK() {
        return this.buffer.equals(SDSMessage_1.SDSMessage.ACK);
    }
    /**
     * Determines if the response is a ACK for SSL Level b, c or d
     * @returns true, if the response is an ACK for SSL Level b, c or d otherwise false
     */
    isACK_SSLLevelB() {
        return this.buffer.equals(SDSMessage_1.SDSMessage.ACK_SSL_LEVEL_B);
    }
    /**
     * Determines if the request was invalid
     * @returns true, if the response is an ACK, otherwise false
     */
    isInvalid() {
        return this.buffer.equals(SDSMessage_1.SDSMessage.INVALID);
    }
    toString() {
        let out = `${JSON.stringify(this.buffer)}\r\n
Buffered length: ${this.bufferedLength}
OId: ${this.oId}
Operation: ${this.operation}
Parameters (${this.parameters.size})`;
        if (this.parameters.size > 0) {
            out += ":";
            for (const value of this.parameters.values()) {
                out += `\r\n${JSON.stringify(value)}`;
            }
        }
        return out;
    }
    /**
     * Returns the value of a parameter
     * @param paramIndex Start index of the parameter
     * @param headType Suggested parameter type (needed for validation)
     * @returns The value of the parameter
     */
    getBooleanParameter(paramIndex, headType) {
        assert.ok((headType & ~SDSMessage_1.Types.NULL_FLAG) === SDSMessage_1.Types.BOOLEAN);
        if (headType & SDSMessage_1.Types.NULL_FLAG) {
            return false;
        }
        else {
            return true;
        }
    }
    /**
     * Returns the value of a parameter
     * @param paramIndex Start index of the parameter
     * @param headType Suggested parameter type (needed for validation)
     * @returns The value of the parameter
     */
    getIntParameter(paramIndex, headType) {
        assert.ok((headType & ~SDSMessage_1.Types.NULL_FLAG) === SDSMessage_1.Types.INT32);
        return (0, network_1.ntohl)(this.buffer, paramIndex + 2);
    }
    /**
     * Extracts the object id from the buffer
     */
    getOIDFromBuffer() {
        // Byte 1 - 4 = Length of the message
        // Byte 5 - 12 = OID
        const oIdFirst = (0, network_1.ntohl)(this.buffer, 4);
        const oIdLast = (0, network_1.ntohl)(this.buffer, 8);
        return `${oIdFirst}:${oIdLast}`;
    }
    /**
     * Returns the value of a parameter
     * @param paramIndex Start index of the parameter
     * @param headType Suggested parameter type (needed for validation)
     * @returns The value of the parameter
     */
    getStringListParameter(paramIndex, headType) {
        assert.ok((headType & ~SDSMessage_1.Types.NULL_FLAG) === SDSMessage_1.Types.STRING_LIST);
        if (headType & SDSMessage_1.Types.NULL_FLAG) {
            return [];
        }
        // ----- header of parameter -----
        // paramIndex[0]: type
        // paramIndex[1]: name-code
        // ----- data-part of parameter -----
        // paramIndex[2..5]: size of data-part of the parameter (StringList)
        // paramIndex[6..9]: size of the StringList (number of elements)
        // paramIndex[10..13]: strLen: size of the first string (bytes)
        // paramIndex[14...]: first string
        // paramIndex[14 + strLen ...]: size of second string
        // paramIndex[14 + strLen + 4 ...]: second string
        // ...
        // const dataPartSize = ntohl(this.buffer, paramIndex + 2);
        const numElem = (0, network_1.ntohl)(this.buffer, paramIndex + 6);
        const returnList = [];
        let listPtr = paramIndex + 10;
        for (let i = 0; i < numElem; i++) {
            const strLen = (0, network_1.ntohl)(this.buffer, listPtr);
            listPtr += 4;
            const str = this.buffer.toString("utf8", listPtr, listPtr + strLen - 1);
            listPtr += strLen;
            returnList.push(str);
        }
        return returnList;
    }
    /**
     * Returns the value of a parameter
     * @param paramIndex Start index of the parameter
     * @param headType Suggested parameter type (needed for validation)
     * @returns The value of the parameter
     */
    getStringParameter(paramIndex, headType) {
        assert.ok((headType & ~SDSMessage_1.Types.NULL_FLAG) === SDSMessage_1.Types.STRING);
        if (headType & SDSMessage_1.Types.NULL_FLAG) {
            return "";
        }
        const strLength = (0, network_1.ntohl)(this.buffer, paramIndex + 2) - 1;
        // Note: we expect here that the opposite party is a JANUS server compiled with UTF-8 support.
        return this.buffer.toString("utf8", paramIndex + 6, paramIndex + 6 + strLength);
    }
    /**
     * Determines the size of the parameter
     * @param paramIndex Index of the parameter in the message buffer
     * @returns Size of the parameter
     */
    paramLength(paramIndex) {
        // head: 2 bytes
        //       head.type: 1 byte
        //       head.name: 1 byte
        //
        // data: 0 or more bytes, depending on head.type
        //       if head.type is Type.Int32 or Type.Date: 4 bytes
        //       if head.type is Type.OID: 8 bytes
        //       and so on
        assert.ok(paramIndex >= FIRST_PARAM_INDEX && paramIndex < this.buffer.length);
        const headType = this.buffer[paramIndex];
        if (headType & SDSMessage_1.Types.NULL_FLAG) {
            // No data, just the head
            return 2;
        }
        switch (headType & ~SDSMessage_1.Types.NULL_FLAG) {
            case SDSMessage_1.Types.BOOLEAN:
                return 2;
            case SDSMessage_1.Types.INT32:
            case SDSMessage_1.Types.DATE:
                return 2 + 4;
            case SDSMessage_1.Types.OID:
                // head: 2 + oid.low: 4 + oid.high: 4
                return 2 + (2 * 4);
            default:
                // head: 2 + size: 4 + whatever the size is
                return 2 + 4 + (0, network_1.ntohl)(this.buffer, paramIndex + 2);
        }
    }
    /**
     * Creates a map with all return parameters of the response
     * @returns Map with all return parameters of the response
     */
    parseResponseParameters() {
        const responseParameters = new Map();
        for (let i = FIRST_PARAM_INDEX; i < this.bufferedLength; i += this.paramLength(i)) {
            const responseParameter = {
                name: parameterNamesMap.get(this.buffer[i + 1]) || "<unknown>",
                nameIndex: this.buffer[i + 1],
                position: i,
                type: typesMap.get(this.buffer[i] & ~SDSMessage_1.Types.NULL_FLAG) || "<unknown>",
                typeIndex: this.buffer[i] & ~SDSMessage_1.Types.NULL_FLAG,
                value: null,
            };
            switch (responseParameter.typeIndex) {
                case SDSMessage_1.Types.BOOLEAN:
                    responseParameter.value = this.getBooleanParameter(i, this.buffer[i]);
                    break;
                case SDSMessage_1.Types.INT32:
                    responseParameter.value = this.getIntParameter(i, SDSMessage_1.Types.INT32);
                    break;
                case SDSMessage_1.Types.STRING:
                    responseParameter.value = this.getStringParameter(i, SDSMessage_1.Types.STRING);
                    break;
                case SDSMessage_1.Types.STRING_LIST:
                    responseParameter.value = this.getStringListParameter(i, SDSMessage_1.Types.STRING_LIST);
                    break;
                case SDSMessage_1.Types.INT32_LIST:
                    // Ja INT32_LIST != STRING_LIST. Implementiert wurde das f√ºr ServerGui.listConnectedClients
                    // Da es funktioniert und es die einzige Codestelle ist, die es verwendet, belassen wir das erst mal so.
                    responseParameter.value = this.getStringListParameter(i, SDSMessage_1.Types.STRING_LIST);
                    break;
                default:
                    throw new Error(`Unknown parameter type: ${responseParameter.typeIndex}`);
            }
            if (responseParameters.has(responseParameter.nameIndex)) {
                // Should never happen, otherwise the JANUS-server is confused
                console.warn(`Parameter ${responseParameter.name} already exists in the parameters map. Ignore incoming and keep already existing. Debugging info: ${JSON.stringify(responseParameter)}`);
            }
            else {
                responseParameters.set(responseParameter.nameIndex, responseParameter);
            }
        }
        return responseParameters;
    }
}
exports.SDSResponse = SDSResponse;
//# sourceMappingURL=SDSResponse.js.map