/// <reference types="node" />
import { CustomOperations } from "../pd-scripting/CustomOperations";
import { PDClass } from "../pd-scripting/PDClass";
import { PDMeta } from "../pd-scripting/PDMeta";
import { PDTools } from "../pd-scripting/PDTools";
import { ServerGui } from "../pd-scripting/ServerGui";
import { SDSRequest } from "./SDSRequest";
import { SDSResponse } from "./SDSResponse";
import { SDSSimpleMessage } from "./SDSSimpleMessage";
export declare class SDSConnection {
    static STREAMING_TIMEOUT: number;
    /** Timeout in milliseconds to wait for a response from the server */
    static TIMEOUT: number;
    /** Custom PD-Operations */
    CustomOperations: CustomOperations;
    /**
     * Resolve function which should be called on disconnect
     */
    disconnectPromiseResolve: (() => void) | null;
    /** Error message, is set e.g. when writing file fails in streaming */
    errorMessage: string;
    /** PDClass functions */
    PDClass: PDClass;
    /** PDMeta functions */
    PDMeta: PDMeta;
    PDTools: PDTools;
    /** Functions of the server gui */
    ServerGui: ServerGui;
    /** Indicates the current connection status */
    private _isConnected;
    /** Buffered bytes of the message */
    private bufferedMessageBytes;
    /** EventEmitter to handle requests and responses between the client and the server */
    private emitter;
    /** File descriptor, used to write a received file */
    private fileDescriptor;
    /** Path to where the received file should be created */
    private fileName;
    /** File size of the received file */
    private fileSize;
    /** Indicates whether a request is currently in process */
    private _isBusy;
    /** Message buffer of a received message */
    private message;
    /** Message size of a received message (needed to know if a message was received completely) */
    private messageSize;
    /** Id of the client connection */
    private _clientId;
    /** Id of the client connection */
    get clientId(): number;
    /**
     * Indicates that a file is received by calling socket.read(size) via the readable event.
     * The readable event can only be used in paused mode.
     * When the readable handler is off, the read method is called internally.
     * The read() method always sends the "data" event, even if it is called in readable handler.
     */
    private pausedMode;
    /** TCP-Socket for the communication with the JANUS-server */
    private socket;
    private writtenFileBytes;
    constructor();
    /**
     * Flag to determine if the connection is established
     */
    get isConnected(): boolean;
    /**
     * Flag to determine, if a request is in progress
     */
    get isBusy(): boolean;
    private promiseTimeout;
    /**
     * Establishes the TCP-connection with the JANUS-server
     * @param clientName Name with which you want to log in to the server
     * @param host Host to connect with (IPv4-adress)
     * @param port Port of the JANUS-server
     * @param tls true, if direct tls should be used
     * @param startTls true, if JANUS startTls should be used
     * @param trustedCas one ore more CA-certificates, the content, not the path
     * @returns The id of the client
     */
    connect(clientName: string, host: string, port?: number, tls?: boolean, startTls?: boolean, trustedCas?: string | string[] | Buffer | Buffer[]): Promise<number>;
    /**
     * Closes the TCP-connection with the JANUS-server
     */
    disconnect(): Promise<void>;
    /**
     * Terminates the TCP-connection
     */
    terminate(): Promise<void>;
    /**
     * Send given message on the wire and immediately return a promise that is fulfilled whenever the response
     * comes in or the timeout is reached.
     *
     * @param request The SDS-Request or a buffer to send. Note: If you pass a buffer, the buffer won't be packed or edited.
     * @param waitForResponse when send() is called from disconnect(), we shouldn't wait for a response because
     *                        we won't get one. When setting this variable to false, we can avoid the timeout error.
     */
    send(request: SDSRequest | Buffer, waitForResponse?: boolean): Promise<SDSResponse | SDSSimpleMessage>;
    /**
     * Send given message on the wire and immediately return a promise that is fulfilled whenever the response
     * comes in or the timeout is reached. Expects that the response is a full qualified SDSResponse
     *
     * @param request The SDS-Request or a buffer to send. Note: If you pass a buffer, the buffer won't be packed or edited.
     * @param waitForResponse when send() is called from disconnect(), we shouldn't wait for a response because
     *                        we won't get one. When setting this variable to false, we can avoid the timeout error.
     * @throws Error if the response is not of type SDSResponse
     */
    sendFullQualified(request: SDSRequest | Buffer, waitForResponse?: boolean): Promise<SDSResponse>;
    /**
     * Send given message on the wire and immediately return a promise that is fulfilled whenever the response
     * comes in or the timeout is reached. Expects that the response is a simple message
     *
     * @param request The SDS-Request or a buffer to send. Note: If you pass a buffer, the buffer won't be packed or edited.
     * @param waitForResponse when send() is called from disconnect(), we shouldn't wait for a response because
     *                        we won't get one. When setting this variable to false, we can avoid the timeout error.
     * @throws Error if the response is not of type SDSSimpleMessage
     */
    sendSimple(request: SDSRequest, waitForResponse?: boolean): Promise<SDSSimpleMessage>;
    /**
     * Performs a file transfer in both directions.
     * This includes
     * 1. sending SDS request
     * 2. switching protocol to transfer (socket paused mode)
     * 3. transferring the file
     * 4. switching protocol back to SDS (socket in flowing mode)
     * 5. receiving SDS response
     *
     * @param request the start request
     * @param fileName the local name of the file
     * @param fileSize the file size
     * @param write true if the server writes the file to client, false if the server reads the file from client
     */
    sendStartAndTransferFile(request: SDSRequest, fileName: string, fileSize: number, write: boolean): Promise<SDSResponse>;
    /**
 * Appends a buffer to the message buffer
 * @param chunk Data to append
 */
    private appendToBuffer;
    /**
     * Close file in fileDescriptor.
     *
     * @param cpTmp true for copying fileName.tmp to fileName
     * @param rmTmp true for removing fileName.tmp
     */
    private closeFile;
    /**
     * When file is sent to server (see sendFileData()), the server will send
     * exactly one code in the end:
     * -3 for cancelling or
     * 0 for showing that the whole file was received without error
     * This code is received via the readable event (see receiveFileData)
     * which triggers this function.
     */
    private receiveErrorCode;
    /**
     * This handler is called by the *readable* event in paused mode.
     * After getting the readable event, socket.read(size) can be called.
     * The JANUS transfer-file sub-protocol requires reading data blocks of specific size:
     * 1. First 4-bytes are the length of the following *data package* in network byte order.
     * 2. The *data package* simply contains the next raw data of the file.
     */
    private receiveFileData;
    /**
     * Handles incoming SDS messages from the server.
     * If a response is received completely, a "response"-event will be triggered.
     * @param data Byte buffer
     */
    private receiveSDSData;
    /**
     * Send a block of data, blocks should have maximum size of 8192.
     * If the blocks are > 8192, server will assume a communication error.
     * @param data the data
     * @param size the size of the data, max. 8192
     */
    private sendDataBlock;
    /**
     * Send the whole file (opened in this.fileDescriptor)
     */
    private sendFileData;
    /**
     * Helper to to wait for the Node.js Event Loop until it
     * enters the poll phase again. I/O is checked at beginning of the poll phase.
     *
     * setImmediate() vs. setTimeout():
     * https://snyk.io/blog/nodejs-how-even-quick-async-functions-can-block-the-event-loop-starve-io/
     * https://rclayton.silvrback.com/scheduling-execution-in-node-js
     */
    private setImmediatePromise;
    /**
     * Sleeps for a given time
     * @param ms Time in milliseconds
     */
    private sleep;
}
