"use strict";
// T O D O's until the refactored version has the same functionality like the old one
// @todo: Function missing: setLanguage (see https://github.com/otris/node-sds/blob/master/src/sds.ts#L313)
// @todo: Function missing: callClassOperation (see https://github.com/otris/node-sds/blob/master/src/sds.ts#L355)
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SDSConnection = void 0;
const events_1 = require("events");
const fs = require("fs-extra");
const net_1 = require("net");
const os = require("os");
const path = require("path");
const promisePrototypeFinally = require("promise.prototype.finally");
const tls_1 = require("tls");
const network_1 = require("../network");
const CustomOperations_1 = require("../pd-scripting/CustomOperations");
const PDClass_1 = require("../pd-scripting/PDClass");
const PDMeta_1 = require("../pd-scripting/PDMeta");
const PDTools_1 = require("../pd-scripting/PDTools");
const ServerGui_1 = require("../pd-scripting/ServerGui");
const SDSMessage_1 = require("./SDSMessage");
const SDSRequest_1 = require("./SDSRequest");
const SDSResponse_1 = require("./SDSResponse");
const SDSSimpleMessage_1 = require("./SDSSimpleMessage");
// make Promise.finally available
promisePrototypeFinally.shim();
class SDSConnection {
    constructor() {
        this.emitter = new events_1.EventEmitter();
        this.message = Buffer.alloc(4096);
        this.bufferedMessageBytes = 0;
        this.messageSize = 0;
        this._isConnected = false;
        this.socket = null;
        this._isBusy = false;
        this.fileDescriptor = -1;
        this.fileName = "";
        this.fileSize = 0;
        this.writtenFileBytes = 0;
        this.pausedMode = false;
        this.errorMessage = "";
        this._clientId = -1;
        this.disconnectPromiseResolve = null;
        // Initialize functions
        this.CustomOperations = null;
        this.PDClass = null;
        this.PDMeta = null;
        this.PDTools = null;
        this.ServerGui = null;
    }
    /** Id of the client connection */
    get clientId() {
        return this._clientId;
    }
    /**
     * Flag to determine if the connection is established
     */
    get isConnected() {
        return this._isConnected;
    }
    /**
     * Flag to determine, if a request is in progress
     */
    get isBusy() {
        return this._isBusy;
    }
    promiseTimeout(promise, milliseconds, error) {
        return new Promise((resolve, reject) => {
            let hasCompleted = false;
            if (milliseconds < 0) {
                throw new TypeError("Milliseconds should be positive: " + milliseconds);
            }
            const timer = setTimeout(() => {
                if (!hasCompleted) {
                    hasCompleted = true;
                    reject(error);
                }
            }, milliseconds);
            (() => __awaiter(this, void 0, void 0, function* () {
                try {
                    const result = yield promise;
                    if (!hasCompleted) {
                        hasCompleted = true;
                        resolve(result);
                    }
                }
                catch (error) {
                    if (!hasCompleted) {
                        hasCompleted = true;
                        reject(error);
                    }
                }
                finally {
                    clearTimeout(timer);
                }
            }))();
        });
    }
    /**
     * Establishes the TCP-connection with the JANUS-server
     * @param clientName Name with which you want to log in to the server
     * @param host Host to connect with (IPv4-adress)
     * @param port Port of the JANUS-server
     * @param tls true, if direct tls should be used
     * @param startTls true, if JANUS startTls should be used
     * @param trustedCas one ore more CA-certificates, the content, not the path
     * @returns The id of the client
     */
    connect(clientName, host, port = 11000, tls = false, startTls = false, trustedCas) {
        const connectPromise = new Promise((resolve, reject) => {
            this.socket = tls
                ? (0, tls_1.connect)({ host, port, servername: host })
                : (0, net_1.createConnection)(port, host);
            this.socket.on("connect", () => __awaiter(this, void 0, void 0, function* () {
                try {
                    this._isConnected = true;
                    // Send the magic to the server to be able to connect and wait for an ACK
                    let response = yield this.sendFullQualified(SDSMessage_1.SDSMessage.HELLO);
                    if (!response.isACK() && !response.isACK_SSLLevelB()) {
                        reject(new Error(`Expected to receive an ACK, got ${response}`));
                    }
                    if (response.isACK_SSLLevelB() || startTls) {
                        // now switch to tls socket, we have to remove and add the listeners again
                        this.socket.removeAllListeners("connect");
                        this.socket.removeAllListeners("error");
                        this.socket.removeAllListeners("close");
                        this.socket.removeAllListeners("end");
                        this.socket.removeAllListeners("data");
                        if (trustedCas) {
                            const secContext = (0, tls_1.createSecureContext)({ ca: trustedCas });
                            this.socket = (0, tls_1.connect)({ secureContext: secContext, socket: this.socket });
                        }
                        else {
                            this.socket = (0, tls_1.connect)({ socket: this.socket });
                        }
                        try {
                            yield new Promise((resolveSecureConnect, rejectSecureConnect) => {
                                this.socket.on("secureConnect", () => __awaiter(this, void 0, void 0, function* () {
                                    if (this.socket instanceof tls_1.TLSSocket && !this.socket.authorized) {
                                        const err = this.socket.authorizationError;
                                        console.log("tls client unauthorized: " + err.message);
                                        yield this.disconnect();
                                        return rejectSecureConnect(err);
                                    }
                                    return resolveSecureConnect("");
                                }));
                                this.socket.on("error", (err) => __awaiter(this, void 0, void 0, function* () {
                                    err.message = `Unhandled error ocurred: The TCP-connection failed: ${err.message}`;
                                    yield this.disconnect();
                                    return rejectSecureConnect(err);
                                }));
                                this.socket.on("close", () => {
                                    this._isConnected = false;
                                    if (this.disconnectPromiseResolve) {
                                        this.disconnectPromiseResolve();
                                    }
                                });
                                this.socket.on("end", () => {
                                    this.socket.end();
                                });
                                this.socket.on("data", this.receiveSDSData.bind(this));
                            });
                        }
                        catch (err) {
                            return reject(err);
                        }
                    }
                    // Send the client name and os
                    const request = new SDSRequest_1.SDSRequest();
                    // @ts-ignore
                    request.operation = 0; // this operation is not labeled. Take it as it is
                    request.add(Buffer.from(SDSMessage_1.SDSMessage.term_utf8(`${clientName} on ${os.platform()}`)));
                    // wait for the client-ID
                    response = yield this.sendFullQualified(request);
                    this._clientId = response.getParameter(SDSMessage_1.ParameterNames.CLIENT_ID);
                    // Initialize functions
                    this.CustomOperations = new CustomOperations_1.CustomOperations(this);
                    this.PDClass = new PDClass_1.PDClass(this);
                    this.PDMeta = new PDMeta_1.PDMeta(this);
                    this.PDTools = new PDTools_1.PDTools(this);
                    this.ServerGui = new ServerGui_1.ServerGui(this);
                    yield this.PDMeta.initialize();
                    resolve(this._clientId);
                }
                catch (err) {
                    return reject(err);
                }
            }));
            this.socket.on("error", (err) => __awaiter(this, void 0, void 0, function* () {
                err.message = `Unhandled error ocurred: The TCP-connection failed: ${err.message}`;
                yield this.disconnect();
                reject(err);
            }));
            this.socket.on("close", () => {
                this._isConnected = false;
                if (this.disconnectPromiseResolve) {
                    this.disconnectPromiseResolve();
                }
            });
            this.socket.on("end", () => {
                this.socket.end();
            });
            this.socket.on("data", this.receiveSDSData.bind(this));
        });
        // this is a workaround for the test execution: Because there is no possibility to set a timeout for the connection
        // attempt, we reject the connection if it exceed a time of X ms
        return this.promiseTimeout(connectPromise, SDSConnection.TIMEOUT, new Error(`Unhandled error ocurred: The TCP-connection failed: connect ETIMEDOUT ${host}:${port}`));
    }
    /**
     * Closes the TCP-connection with the JANUS-server
     */
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                if (this.socket) {
                    // send a disconnect message to the client
                    if (this.PDClass) {
                        yield this.PDClass.disconnectClient();
                    }
                    this.socket.destroy();
                    resolve();
                }
                else {
                    resolve();
                }
            }));
        });
    }
    /**
     * Terminates the TCP-connection
     */
    terminate() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.socket) {
                this.socket.destroy();
                this._isBusy = false;
                this._isConnected = false;
            }
        });
    }
    /**
     * Send given message on the wire and immediately return a promise that is fulfilled whenever the response
     * comes in or the timeout is reached.
     *
     * @param request The SDS-Request or a buffer to send. Note: If you pass a buffer, the buffer won't be packed or edited.
     * @param waitForResponse when send() is called from disconnect(), we shouldn't wait for a response because
     *                        we won't get one. When setting this variable to false, we can avoid the timeout error.
     */
    send(request, waitForResponse = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected) {
                throw new Error("The client is not connected");
            }
            // Wait as long as a request is active
            while (this._isBusy) {
                yield this.sleep(500);
            }
            // if send is called by disconnect(), the server sends no response,
            // so call send without waiting for response to avoid the timeout error
            if (!waitForResponse) {
                return new Promise((resolve) => {
                    if (request instanceof SDSRequest_1.SDSRequest) {
                        this.socket.write(request.pack());
                    }
                    else {
                        this.socket.write(request);
                    }
                    // @todo: Create a qualified "disconnect" response
                    resolve({});
                });
            }
            else {
                // mark as busy to prevent that requests are send parallel
                this._isBusy = true;
                // Register for the response event and send the request
                const response = new Promise((resolve) => {
                    this.emitter.once("response", resolve);
                });
                if (request instanceof SDSRequest_1.SDSRequest) {
                    this.socket.write(request.pack());
                }
                else {
                    this.socket.write(request);
                }
                // Return a Promise which automatically rejects if the server did not response
                // for a given time
                return this.promiseTimeout(response, SDSConnection.TIMEOUT, new Error(`Request timed out (after ${SDSConnection.TIMEOUT} ms)`)).finally(() => {
                    this._isBusy = false;
                });
            }
        });
    }
    /**
     * Send given message on the wire and immediately return a promise that is fulfilled whenever the response
     * comes in or the timeout is reached. Expects that the response is a full qualified SDSResponse
     *
     * @param request The SDS-Request or a buffer to send. Note: If you pass a buffer, the buffer won't be packed or edited.
     * @param waitForResponse when send() is called from disconnect(), we shouldn't wait for a response because
     *                        we won't get one. When setting this variable to false, we can avoid the timeout error.
     * @throws Error if the response is not of type SDSResponse
     */
    sendFullQualified(request, waitForResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const response = yield this.send(request, waitForResponse);
                    if (response instanceof SDSResponse_1.SDSResponse) {
                        resolve(response);
                    }
                    else {
                        reject(new Error(`Received a message of type '${response.constructor.name}' but expected to receive a message of type 'SDSResponse'`));
                    }
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
     * Send given message on the wire and immediately return a promise that is fulfilled whenever the response
     * comes in or the timeout is reached. Expects that the response is a simple message
     *
     * @param request The SDS-Request or a buffer to send. Note: If you pass a buffer, the buffer won't be packed or edited.
     * @param waitForResponse when send() is called from disconnect(), we shouldn't wait for a response because
     *                        we won't get one. When setting this variable to false, we can avoid the timeout error.
     * @throws Error if the response is not of type SDSSimpleMessage
     */
    sendSimple(request, waitForResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const response = yield this.send(request, waitForResponse);
                    if (response instanceof SDSSimpleMessage_1.SDSSimpleMessage) {
                        resolve(response);
                    }
                    else {
                        reject(new Error(`Received a message of type '${response.constructor.name}' but expected to receive a message of type 'SDSSimpleMessage'`));
                    }
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    /**
     * Performs a file transfer in both directions.
     * This includes
     * 1. sending SDS request
     * 2. switching protocol to transfer (socket paused mode)
     * 3. transferring the file
     * 4. switching protocol back to SDS (socket in flowing mode)
     * 5. receiving SDS response
     *
     * @param request the start request
     * @param fileName the local name of the file
     * @param fileSize the file size
     * @param write true if the server writes the file to client, false if the server reads the file from client
     */
    sendStartAndTransferFile(request, fileName, fileSize, write) {
        return __awaiter(this, void 0, void 0, function* () {
            //  create local folder for receive file
            if (write) {
                fs.mkdirpSync(path.dirname(fileName));
            }
            this.fileDescriptor = write ? fs.openSync(fileName + ".tmp", "wx") : fs.openSync(fileName, "r");
            this.fileSize = fileSize;
            this.fileName = fileName;
            this.errorMessage = "";
            // switching socket to paused mode => no SDS messages can be received
            // switching socket back to flowing mode is done in receiveCode after file transfer
            this.pausedMode = true;
            this.socket.pause();
            this.socket.on("readable", write ? this.receiveFileData.bind(this) : this.receiveErrorCode.bind(this));
            // after socket was switched back to flowing mode there will be exactly one SDS response,
            // registering for this response
            const response = this.promiseTimeout(new Promise((resolve) => this.emitter.once("response", resolve)), SDSConnection.STREAMING_TIMEOUT, new Error(`Request timed out (after ${SDSConnection.STREAMING_TIMEOUT} ms)`));
            // notifying server, that the data will be sent now
            yield this.send(request, false);
            // sending data
            // receiving data is done via the *readable* event
            if (!write) {
                yield this.sendFileData();
            }
            // after the file was transferred response, will be resolved
            return response;
        });
    }
    /**
 * Appends a buffer to the message buffer
 * @param chunk Data to append
 */
    appendToBuffer(chunk) {
        const spaceLeft = this.message.length - this.bufferedMessageBytes;
        if (spaceLeft < chunk.length) {
            const newCapacity = Math.max(this.bufferedMessageBytes + chunk.length, 1.5 * this.message.length);
            const newBuffer = Buffer.alloc(newCapacity);
            this.message.copy(newBuffer);
            this.message = newBuffer;
        }
        chunk.copy(this.message, this.bufferedMessageBytes);
        this.bufferedMessageBytes += chunk.length;
    }
    /**
     * Close file in fileDescriptor.
     *
     * @param cpTmp true for copying fileName.tmp to fileName
     * @param rmTmp true for removing fileName.tmp
     */
    closeFile(cpTmp, rmTmp) {
        fs.closeSync(this.fileDescriptor);
        this.fileDescriptor = -1;
        if (cpTmp) {
            fs.copySync(this.fileName + ".tmp", this.fileName);
        }
        if (rmTmp) {
            fs.removeSync(this.fileName + ".tmp");
        }
    }
    /**
     * When file is sent to server (see sendFileData()), the server will send
     * exactly one code in the end:
     * -3 for cancelling or
     * 0 for showing that the whole file was received without error
     * This code is received via the readable event (see receiveFileData)
     * which triggers this function.
     */
    receiveErrorCode() {
        const buf = this.socket.read(4);
        if (buf === null) {
            return;
        }
        // server sends -3 to cancel sending file
        // or 0 when the whole file was received
        const value = (0, network_1.ntohl)(buf, 0);
        if (value <= -3) {
            // confirm cancellation
            this.socket.write(Buffer.from([0, 0, 0, 0]));
        }
        // in both cases close file and
        // switch back to sds communication
        this.closeFile(false, false);
        this.pausedMode = false;
        this.socket.removeAllListeners("readable");
        this.socket.resume();
    }
    /**
     * This handler is called by the *readable* event in paused mode.
     * After getting the readable event, socket.read(size) can be called.
     * The JANUS transfer-file sub-protocol requires reading data blocks of specific size:
     * 1. First 4-bytes are the length of the following *data package* in network byte order.
     * 2. The *data package* simply contains the next raw data of the file.
     */
    receiveFileData() {
        let buf;
        // call socket.read() until it returns null
        while (true) {
            if (this.messageSize === 0) {
                // get size or error/end code
                buf = this.socket.read(4);
                if (buf === null) {
                    // available bytes < 4, try again...
                    break;
                }
                const errorCode = (0, network_1.ntohl)(buf, 0);
                if (errorCode === -1 || errorCode === -2 || errorCode > 8192) {
                    this.closeFile(false, true);
                    throw new Error("Communication error in streaming");
                }
                if (errorCode === 0 || errorCode <= 3) {
                    // end of streaming
                    // switch back to SDS communication (before calling send!)
                    this.pausedMode = false;
                    this.socket.removeAllListeners("readable");
                    this.socket.resume();
                    // check end state, 3 cases
                    if (errorCode === 0 && this.fileDescriptor < 0) {
                        // case 1: we cancelled (see below), server confirmed with 0
                    }
                    else if (errorCode <= -3) {
                        // case 2: server cancelled, we must confirm with 0
                        this.socket.write(new Buffer([0, 0, 0, 0]));
                        this.closeFile(false, true);
                    }
                    else if (errorCode === 0) {
                        // case 3: server sent end code, we must confirm with 0
                        this.socket.write(new Buffer([0, 0, 0, 0]));
                        this.closeFile(true, true);
                    }
                    this.messageSize = 0;
                    this.writtenFileBytes = 0;
                    break;
                }
                // communication still alive, we got the message size
                this.messageSize = errorCode;
            }
            // get data
            buf = this.socket.read(this.messageSize);
            if (buf === null) {
                // try again until the whole package is available
                break;
            }
            this.messageSize = 0;
            if (this.fileDescriptor < 0) {
                // we sent cancellation code to server (see below),
                // we must continue receiving data until the server
                // sends the end code
                continue;
            }
            // write data
            let written = -1;
            try {
                if ((this.writtenFileBytes + buf.length) > this.fileSize) {
                    throw new Error(`Received ${(this.writtenFileBytes + buf.length)} but expected only ${this.fileSize}`);
                }
                // what if written !== buf.length? insert while?
                written = fs.writeSync(this.fileDescriptor, buf);
                this.writtenFileBytes += written;
            }
            catch (err) {
                const errorMessage = err instanceof Error ? err.message : "" + err;
                this.errorMessage = errorMessage;
            }
            if (written !== buf.length) {
                // send cancellation code to server, server will confirm with [0,0,0,0]
                this.socket.write(Buffer.from([-1, -1, -1, -3]));
                this.closeFile(false, true);
            }
        }
    }
    /**
     * Handles incoming SDS messages from the server.
     * If a response is received completely, a "response"-event will be triggered.
     * @param data Byte buffer
     */
    receiveSDSData(data) {
        if (this.pausedMode) {
            // socket.read() in receiveFileData() triggered this data event
            // but the data were already handled in receiveFileData()
            return;
        }
        if (data.equals(SDSMessage_1.SDSMessage.INVALID)) {
            throw new Error("Request was invalid");
        }
        else if (data.equals(SDSMessage_1.SDSMessage.ACK) || data.equals(SDSMessage_1.SDSMessage.ACK_SSL_LEVEL_B)) {
            this.emitter.emit("response", new SDSResponse_1.SDSResponse(data, false));
        }
        else {
            if (this.messageSize === 0) {
                // We got a new message, check the size and wait until we received the message completely
                this.messageSize = (0, network_1.ntohl)(data, 0);
            }
            // Append to the buffer and wait for the rest
            this.appendToBuffer(data);
            if (this.bufferedMessageBytes === this.messageSize) {
                // We received the message completely. Handle it
                const responseBuffer = this.message.slice(0, this.messageSize);
                let response;
                if (responseBuffer.length === 8) {
                    response = new SDSSimpleMessage_1.SDSSimpleMessage(responseBuffer);
                }
                else {
                    response = new SDSResponse_1.SDSResponse(responseBuffer);
                }
                this.emitter.emit("response", response);
                // Reset the message variables
                this.messageSize = this.bufferedMessageBytes = 0;
                this.message = Buffer.alloc(4096);
            }
        }
    }
    /**
     * Send a block of data, blocks should have maximum size of 8192.
     * If the blocks are > 8192, server will assume a communication error.
     * @param data the data
     * @param size the size of the data, max. 8192
     */
    sendDataBlock(data, size) {
        // first send the size of the data package
        const lenBuf = Buffer.alloc(4);
        (0, network_1.htonl)(lenBuf, 0, size);
        this.socket.write(lenBuf);
        // then send the data package
        const dataBuf = Buffer.alloc(size);
        data.copy(dataBuf, 0, 0, size);
        this.socket.write(dataBuf);
    }
    /**
     * Send the whole file (opened in this.fileDescriptor)
     */
    sendFileData() {
        return __awaiter(this, void 0, void 0, function* () {
            let sent = 0;
            const maxLen = 8192;
            const data = Buffer.alloc(maxLen);
            // send file until server sends end/error code
            while (true) {
                // waiting for I/O, meaning receiving data from server in receiveErrorCode
                // server will send exactly one code in the end (-3 for cancel, 0 for file received)
                yield this.setImmediatePromise();
                if (this.fileDescriptor < 0) {
                    // server sent end/error code
                    // confirmation was sent in receiveErrorCode
                    break;
                }
                if (sent < this.fileSize) {
                    const len = fs.readSync(this.fileDescriptor, data, 0, maxLen, null);
                    if (len <= 0 || (sent + len) > this.fileSize) {
                        // send cancellation code
                        // triggers receiveCod and sets fileDescriptor = -1
                        this.socket.write(Buffer.from([-1, -1, -1, -3]));
                    }
                    this.sendDataBlock(data, len);
                    sent += len;
                    if (sent === this.fileSize) {
                        // ready, send end code
                        // triggers receiveCancel and sets fileDescriptor = -1
                        this.socket.write(Buffer.from([0, 0, 0, 0]));
                    }
                }
            }
        });
    }
    /**
     * Helper to to wait for the Node.js Event Loop until it
     * enters the poll phase again. I/O is checked at beginning of the poll phase.
     *
     * setImmediate() vs. setTimeout():
     * https://snyk.io/blog/nodejs-how-even-quick-async-functions-can-block-the-event-loop-starve-io/
     * https://rclayton.silvrback.com/scheduling-execution-in-node-js
     */
    setImmediatePromise() {
        return new Promise((resolve) => {
            setImmediate(() => resolve());
        });
    }
    /**
     * Sleeps for a given time
     * @param ms Time in milliseconds
     */
    sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
}
exports.SDSConnection = SDSConnection;
SDSConnection.STREAMING_TIMEOUT = 60000;
/** Timeout in milliseconds to wait for a response from the server */
SDSConnection.TIMEOUT = 6000;
//# sourceMappingURL=SDSConnection.js.map