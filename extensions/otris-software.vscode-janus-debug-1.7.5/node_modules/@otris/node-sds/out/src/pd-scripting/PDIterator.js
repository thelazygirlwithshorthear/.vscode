"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PDIterator = void 0;
const PDClass_1 = require("./PDClass");
const PDObject_1 = require("./PDObject");
class PDIterator {
    constructor(connection) {
        this.connection = connection;
        this._iterator = this._classNameOrIdOrPDO = -1;
        this._listName = "";
        this._filter = "";
        this._sort = "";
    }
    get classNameOrIdOrPDO() {
        return this._classNameOrIdOrPDO;
    }
    get filter() {
        return this._filter;
    }
    /**
     * Id of the iterator
     */
    get iteratorNo() {
        return this._iterator;
    }
    get listName() {
        return this._listName;
    }
    get pdObject() {
        return this._pdObject;
    }
    get sort() {
        return this._sort;
    }
    /**
     * Creates a copy of the current iterator.
     * The position of the iterator will not be copied. This function creates only a new iterator
     * with the same filter and sort options.
     */
    cloneIterator() {
        const iterator = new PDIterator(this.connection);
        return iterator.createIterator(this._classNameOrIdOrPDO, this._filter, this._sort, this._pdObject, this._listName);
    }
    /**
     * Closes the iterator
     * @param iteratorId
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._classNameOrIdOrPDO instanceof PDObject_1.PDObject) {
                yield this._classNameOrIdOrPDO.deleteIterator(this.iteratorNo);
            }
            else {
                yield this.connection.PDClass.deleteIterator(this.iteratorNo);
            }
            this._iterator = -1;
        });
    }
    /**
     * Creates a new PDIterator
     * @param classNameOrIdOrPDO Class name of the objects to iterate on
     * @param filter Filter criteria
     * @param sort Sort criteria
     * @param pdObject PDObject the objects are related to
     * @param listName User defined list name to iterate on
     * @returns The id of the iterator
     */
    createIterator(classNameOrIdOrPDO, filter = "", sort = "", pdObject, listName = "") {
        return __awaiter(this, void 0, void 0, function* () {
            this._classNameOrIdOrPDO = classNameOrIdOrPDO;
            this._listName = listName;
            this._filter = filter;
            this._sort = sort;
            this._pdObject = pdObject;
            if (classNameOrIdOrPDO instanceof PDObject_1.PDObject) {
                this._iterator = yield classNameOrIdOrPDO.newIterator(filter, "", sort);
            }
            else {
                this._iterator = yield this.connection.PDClass.newIterator(classNameOrIdOrPDO, filter, sort, pdObject, listName);
            }
            return this;
        });
    }
    /**
     * Returns the first hit of the iterator
     */
    first() {
        if (this._classNameOrIdOrPDO instanceof PDObject_1.PDObject) {
            return this._classNameOrIdOrPDO.seekFirst(this._iterator);
        }
        else {
            return this.connection.PDClass.seekFirst(this._iterator);
        }
    }
    /**
     * Checks if theres is a next element on the iterator
     */
    hasNext() {
        if (this._classNameOrIdOrPDO instanceof PDObject_1.PDObject) {
            return this._classNameOrIdOrPDO.hasNext(this._iterator);
        }
        else {
            return this.connection.PDClass.hasNext(this._iterator);
        }
    }
    /**
     * Checks if theres is a previous element on the iterator
     */
    hasPrev() {
        if (this._classNameOrIdOrPDO instanceof PDObject_1.PDObject) {
            return this._classNameOrIdOrPDO.hasPrev(this._iterator);
        }
        else {
            return this.connection.PDClass.hasPrev(this._iterator);
        }
    }
    /**
     * Returns the last element of the iterator
     */
    last() {
        // Man muss als offset "1" angeben, um an das letzte Element zu kommen
        const offset = 1;
        if (this._classNameOrIdOrPDO instanceof PDObject_1.PDObject) {
            return this._classNameOrIdOrPDO.seekObject(this._iterator, offset, PDClass_1.PDIteratorPositions.LAST);
        }
        else {
            return this.connection.PDClass.seekObject(this._iterator, offset, PDClass_1.PDIteratorPositions.LAST);
        }
    }
    /**
     * Returns the next hit of the iterator
     */
    next() {
        if (this._classNameOrIdOrPDO instanceof PDObject_1.PDObject) {
            return this._classNameOrIdOrPDO.seekNext(this._iterator);
        }
        else {
            return this.connection.PDClass.seekNext(this._iterator);
        }
    }
    /**
     * Returns the previous hit of the iterator
     */
    previous() {
        if (this._classNameOrIdOrPDO instanceof PDObject_1.PDObject) {
            return this._classNameOrIdOrPDO.seekObject(this._iterator, -1, PDClass_1.PDIteratorPositions.CURRENT);
        }
        else {
            return this.connection.PDClass.seekObject(this._iterator, -1, PDClass_1.PDIteratorPositions.CURRENT);
        }
    }
    /**
     * Moves the iterator to a given position
     * @param position
     * @param offset
     */
    seekObject(position, offset) {
        if (this._classNameOrIdOrPDO instanceof PDObject_1.PDObject) {
            return this._classNameOrIdOrPDO.seekObject(this._iterator, position, offset);
        }
        else {
            return this.connection.PDClass.seekObject(this._iterator, position, offset);
        }
    }
    /**
     * Returns the number of elements of the PDIterator
     */
    size() {
        if (this._classNameOrIdOrPDO instanceof PDObject_1.PDObject) {
            return this._classNameOrIdOrPDO.countObjects(this._filter, this._listName);
        }
        else {
            return this.connection.PDClass.countObjects(this._classNameOrIdOrPDO, this._listName, this._filter);
        }
    }
}
exports.PDIterator = PDIterator;
//# sourceMappingURL=PDIterator.js.map