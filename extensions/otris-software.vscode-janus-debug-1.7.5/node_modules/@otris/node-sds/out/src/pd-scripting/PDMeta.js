"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PDMeta = void 0;
const SDSMessage_1 = require("../sds/SDSMessage");
const SDSRequest_1 = require("../sds/SDSRequest");
const JANUSClass_1 = require("./JANUSClass");
class PDMeta extends JANUSClass_1.JANUSClass {
    constructor(sdsConnection) {
        super(sdsConnection);
        this.pdClassesMap = new Map();
        this.pdClassesIdMap = new Map();
    }
    /**
     * Converts an error code to a error message.
     * This message returns a human-readable string (probably in German) for a given error code.
     * @param errorCode The error code from a previous SDS call.
     * @returns The error message
     */
    errorMessage(errorCode) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.COM_OPERATION;
                request.addParameter(SDSMessage_1.ParameterNames.INDEX, SDSMessage_1.ComOperations.ERROR_MESSAGE);
                request.addParameter(SDSMessage_1.ParameterNames.VALUE, errorCode);
                const response = yield this.connection.sendFullQualified(request);
                resolve(response.getParameter(SDSMessage_1.ParameterNames.RETURN_VALUE));
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Returns the class id of class which the passed relation is connected to
     * @param classId Id of the class (left side of the relation)
     * @param relationName Name of the relation
     */
    getAssocClass(classId, relationName) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.COM_OPERATION;
            request.addParameter(SDSMessage_1.ParameterNames.INDEX, SDSMessage_1.PDMeta_COMOperations.GET_ASSOC_CLASS);
            request.addParameter(SDSMessage_1.ParameterNames.CLASS_ID, classId);
            request.addParameter(SDSMessage_1.ParameterNames.RELATION_NAME, relationName);
            const response = yield this.connection.sendFullQualified(request);
            return response.getParameter(SDSMessage_1.ParameterNames.RETURN_VALUE);
        });
    }
    /**
     * Returns the relations of the given class
     * @param className Name of the class
     */
    getAssocs(className) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.COM_OPERATION;
            request.addParameter(SDSMessage_1.ParameterNames.INDEX, SDSMessage_1.PDMeta_COMOperations.GET_ASSOCS);
            request.addParameter(SDSMessage_1.ParameterNames.CLASS_NAME, className);
            const response = yield this.connection.sendFullQualified(request);
            return response.getParameter(SDSMessage_1.ParameterNames.RETURN_VALUE);
        });
    }
    /**
     * Returns the names of all attributes of the given class
     * @param className Name of the class
     * @param flags Defines which attributes should be returned
     */
    getAttributes(className, flags) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.COM_OPERATION;
            request.addParameter(SDSMessage_1.ParameterNames.INDEX, SDSMessage_1.PDMeta_COMOperations.GET_ATTRIBUTES);
            request.addParameter(SDSMessage_1.ParameterNames.CLASS_NAME, className);
            request.addParameter(SDSMessage_1.ParameterNames.ATTRS, flags);
            const response = yield this.connection.sendFullQualified(request);
            return response.getParameter(SDSMessage_1.ParameterNames.RETURN_VALUE);
        });
    }
    /**
     * Returns the class name according to the passed id
     * @param classId Id of the class
     * @returns The class name
     */
    getClass(classId) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.pdClassesIdMap.has(classId)) {
                    resolve(this.pdClassesIdMap.get(classId));
                }
                else {
                    const request = new SDSRequest_1.SDSRequest();
                    request.operation = SDSMessage_1.Operations.COM_OPERATION;
                    request.addParameter(SDSMessage_1.ParameterNames.INDEX, SDSMessage_1.ComOperations.GET_CLASS_NAME);
                    request.addParameter(SDSMessage_1.ParameterNames.CLASS_ID, classId);
                    const response = yield this.connection.sendFullQualified(request);
                    const className = response.getParameter(SDSMessage_1.ParameterNames.RETURN_VALUE);
                    if (className === "") {
                        const errorMessage = yield this.getFormattedError(`Can't get class name of class id '${classId}': The class does not exist`);
                        throw new Error(errorMessage);
                    }
                    else {
                        resolve(className);
                    }
                }
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Returns a list with the name of available PDClasses of the JANUS-application
     * @param abstractClasses Determines if abstract classes should be returned
     * @returns List with the class names
     */
    getClasses(abstractClasses = false) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.COM_OPERATION;
                request.addParameter(SDSMessage_1.ParameterNames.INDEX, SDSMessage_1.ComOperations.GET_CLASSES);
                request.addParameter(SDSMessage_1.ParameterNames.PROPERTIES, abstractClasses);
                const response = yield this.connection.sendFullQualified(request);
                const classNames = response.getParameter(SDSMessage_1.ParameterNames.RETURN_VALUE);
                resolve(classNames);
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Resolves the internal class id for the passed class
     * @param className Name of the class
     * @returns Id of the class
     */
    getClassId(className) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.pdClassesMap.has(className)) {
                    resolve(this.pdClassesMap.get(className));
                }
                else {
                    const request = new SDSRequest_1.SDSRequest();
                    request.operation = SDSMessage_1.Operations.COM_OPERATION;
                    request.addParameter(SDSMessage_1.ParameterNames.INDEX, SDSMessage_1.ComOperations.GET_CLASS_ID);
                    request.addParameter(SDSMessage_1.ParameterNames.CLASS_NAME, className);
                    const response = yield this.connection.sendFullQualified(request);
                    const classId = response.getParameter(SDSMessage_1.ParameterNames.CLASS_ID);
                    if (classId < 0) {
                        const errorMessage = yield this.getFormattedError(`Can't get the id of class '${className}': The class does not exist`);
                        throw new Error(errorMessage);
                    }
                    this.pdClassesMap.set(className, classId);
                    this.pdClassesIdMap.set(classId, className);
                    resolve(classId);
                }
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Returns a description of the passed class or class member
     * @param longDescription Determines if a long or a short description summary should be returned
     * @param className Name of the class
     * @param attributeOrOperationName Name of a class member or class operation
     * @param lang Language of the description
     */
    getDescription(longDescription, className, attributeOrOperationName, lang = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.COM_OPERATION;
            request.addParameter(SDSMessage_1.ParameterNames.INDEX, SDSMessage_1.PDMeta_COMOperations.GET_DESCRIPTION);
            request.addParameter(SDSMessage_1.ParameterNames.SOMETHING, longDescription);
            request.addParameter(SDSMessage_1.ParameterNames.CLASS_NAME, className);
            if (attributeOrOperationName) {
                request.addParameter(SDSMessage_1.ParameterNames.RELATION_NAME, attributeOrOperationName);
            }
            request.addParameter(SDSMessage_1.ParameterNames.LANGUAGE, lang);
            const response = yield this.connection.sendFullQualified(request);
            return response.getParameter(SDSMessage_1.ParameterNames.RETURN_VALUE);
        });
    }
    /**
     * Returns the ergonomic label of the class or class member
     * @param classId Id of the class
     * @param memberOrRole Name of the role
     * @param lang Language of the ergName
     */
    getErgname(classId, memberOrRole, lang = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.COM_OPERATION;
            request.addParameter(SDSMessage_1.ParameterNames.INDEX, SDSMessage_1.PDMeta_COMOperations.GET_ERGNAME);
            request.addParameter(SDSMessage_1.ParameterNames.CLASS_ID, classId);
            if (memberOrRole) {
                request.addParameter(SDSMessage_1.ParameterNames.RELATION_NAME, memberOrRole);
            }
            request.addParameter(SDSMessage_1.ParameterNames.LANGUAGE, lang);
            const response = yield this.connection.sendFullQualified(request);
            return response.getParameter(SDSMessage_1.ParameterNames.RETURN_VALUE);
        });
    }
    /**
     * Converts an error code to a error message
     * This message returns a human-readable string (probably in German) for a given error code.
     * @param errorCode The error code from a previous SDS call.
     * @returns The error message
     */
    getString(errorCode) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.PDMETA_GETSTRING;
                request.addParameter(SDSMessage_1.ParameterNames.VALUE, errorCode);
                const response = yield this.connection.sendFullQualified(request);
                const errorMessage = response.getParameter(SDSMessage_1.ParameterNames.RETURN_VALUE);
                resolve(errorMessage);
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Initializes internal members. This function will be invoked by the function constructor
     * but it's executed asynchronously. This function bocks the sdsConnection so that no new
     * requests can be send until this function is finished
     */
    initialize() {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                // get all class names
                const classNamesArray = yield this.getClasses();
                for (const className of classNamesArray) {
                    // get the id of the class and save the result to the class name map
                    const classId = yield this.getClassId(className);
                    this.pdClassesMap.set(className, classId);
                }
                resolve();
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    setLanguage(language) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.PDMETA_SETLANGUAGE;
                request.addParameter(SDSMessage_1.ParameterNames.LANGUAGE, language);
                yield this.connection.sendFullQualified(request);
                resolve();
            }
            catch (err) {
                reject(err);
            }
        }));
    }
}
exports.PDMeta = PDMeta;
//# sourceMappingURL=PDMeta.js.map