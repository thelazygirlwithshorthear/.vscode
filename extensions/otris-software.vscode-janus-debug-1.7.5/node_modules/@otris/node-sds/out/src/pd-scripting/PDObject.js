"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PDObject = void 0;
const SDSMessage_1 = require("../sds/SDSMessage");
const SDSRequest_1 = require("../sds/SDSRequest");
const JANUSClass_1 = require("./JANUSClass");
class PDObject extends JANUSClass_1.JANUSClass {
    constructor(sdsConnection, _oId, classId, className) {
        super(sdsConnection);
        this._oId = _oId;
        this._classId = classId;
        this._className = className;
        this._isTransactional = parseInt(this._oId.split(":")[1], 10) < 0;
    }
    /** ID of the class */
    get classId() {
        /** @TODO: Fetch this property if it's not set */
        return this._classId;
    }
    /** Class name of the PD-Object */
    get className() {
        /** @TODO: Fetch this property if it's not set */
        return this._className;
    }
    /** Indicates if an object is a transaction object or not */
    get isTransactional() {
        return this._isTransactional;
    }
    /** Object-ID of the PD-Object */
    get oId() {
        return this._oId;
    }
    /**
     * Executes an operation on the JANUS-server
     * @todo This function is untested
     * @param operation Name of the operation
     * @param parameters The parameters of the operation
     * @param parametersPDO TODO
     * @returns Execution result of the operation
     */
    callOperation(operation, parameters, pdObjects) {
        return this.callOperationInternal(false, operation, parameters, pdObjects);
    }
    /**
     * Executes an operation on the JANUS-server asynchronously
     * @todo This function is untested
     * @param operation Name of the operation
     * @param parameters The parameters of the operation
     * @param parametersPDO TODO
     */
    callOperationAsync(operation, parameters, pdObjects) {
        return this.callOperationInternal(true, operation, parameters, pdObjects);
    }
    /**
     * Commits a transaction. Note: This operation has to be called from the transaction object
     * @param pdObject Newly created object
     */
    commitTransaction(pdObject) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.oId = this.oId;
            request.operation = SDSMessage_1.Operations.PDOBJECT_COMMIT_TRANSACTION;
            request.addParameter(SDSMessage_1.ParameterNames.OTHER_OBJECT_ID, pdObject.oId);
            // commitTransaction hat keinen Rückgabewert, der geprüft werden könnte
            yield this.connection.send(request);
        });
    }
    connect(relationName, connectTo, lockId) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.oId = this.oId;
            request.operation = SDSMessage_1.Operations.PDOBJECT_CONNECT;
            request.addParameter(SDSMessage_1.ParameterNames.RELATION_NAME, relationName);
            request.addParameter(SDSMessage_1.ParameterNames.OTHER_OBJECT_ID, connectTo.oId);
            if (lockId) {
                request.addParameter(SDSMessage_1.ParameterNames.LOCK_GROUP, lockId);
            }
            const response = yield this.connection.sendSimple(request);
            if (response.result !== 1) {
                const errorMessage = yield this.getFormattedError("Can't count objects", response.result);
                throw new Error(errorMessage);
            }
        });
    }
    /**
     * Counts all elements of the class of the PDObject
     * @param relationName
     * @param filter
     * @param otherPDObject
     */
    countObjects(relationName = "", filter = "", otherPDObject) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.oId = this.oId;
            request.operation = SDSMessage_1.Operations.PDOBJECT_COUNT_OBJECT;
            request.addParameter(SDSMessage_1.ParameterNames.RELATION_NAME, relationName);
            request.addParameter(SDSMessage_1.ParameterNames.SELECT, filter);
            request.addParameter(SDSMessage_1.ParameterNames.OTHER_OBJECT_ID, (otherPDObject) ? otherPDObject.oId : "0:0");
            const response = yield this.connection.sendSimple(request);
            if (response.result < 0) {
                const errorMessage = yield this.getFormattedError("Can't count objects", response.result);
                throw new Error(errorMessage);
            }
            else {
                return response.result;
            }
        });
    }
    /**
     * Removes an open iterator
     * @param iteratorId
     */
    deleteIterator(iteratorId) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.PDOBJECT_DELETE_ITERATOR;
            request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_ID, iteratorId);
            // Operation returns "-1" in case of success
            yield this.connection.send(request);
        });
    }
    /**
     * Returns the value of an attribute
     * @param attributeName Name of the attribute
     * @returns Value of the attribute
     */
    getAttribute(attributeName) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.oId = this.oId;
                request.operation = SDSMessage_1.Operations.PDOBJECT_GETATTRIBUTE;
                request.addParameter(SDSMessage_1.ParameterNames.CLASS_NAME, attributeName);
                const response = yield this.connection.sendFullQualified(request);
                // @todo: The return value represent some flags which gives us informations about the success of this operation
                //        but I don't know how to evaluate these flags
                // const result = response.getParameter(ParameterNames.RETURN_VALUE) as number;
                const attributeValue = response.getParameter(SDSMessage_1.ParameterNames.VALUE);
                resolve(attributeValue);
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Returns true if the iterator points not to the last element of the iterator
     * @param iteratorId Id of the iterator
     */
    hasNext(iteratorId) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.PDOBJECT_HAS_NEXT;
            request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_ID, iteratorId);
            const response = yield this.connection.sendSimple(request);
            return (response.result === 1);
        });
    }
    /**
     * Returns true if the iterator points not to the first element of the iterator
     * @param iteratorId Id of the Iterator
     */
    hasPrev(iteratorId) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.PDOBJECT_HAS_PREV;
            request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_ID, iteratorId);
            const response = yield this.connection.sendSimple(request);
            return (response.result === 1);
        });
    }
    /**
     * Creates a new PDIterator
     * @param relationName Relation name of to iterate on
     * @param filter Filter criteria
     * @param sort Sort criteria
     * @param pdObject PDObject the objects are related to
     * @returns The id of the iterator
     */
    newIterator(relationName = "", filter = "", sort = "", otherPDObject) {
        return __awaiter(this, arguments, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.oId = this.oId;
            request.operation = SDSMessage_1.Operations.PDOBJECT_NEWITERATOR;
            request.addParameter(SDSMessage_1.ParameterNames.RELATION_NAME, relationName);
            request.addParameter(SDSMessage_1.ParameterNames.SELECT, filter);
            request.addParameter(SDSMessage_1.ParameterNames.SORT_EXPRESSION, sort);
            request.addParameter(SDSMessage_1.ParameterNames.OTHER_OBJECT_ID, (otherPDObject) ? otherPDObject.oId : "0:0");
            const response = yield this.connection.sendSimple(request);
            if (response.result < 0) {
                // eslint-disable-next-line prefer-rest-params
                const errorMessage = yield this.getFormattedError(`Iterator instantiation failed. Arguments: ${JSON.stringify(arguments)}`);
                throw new Error(errorMessage);
            }
            return response.result;
        });
    }
    /**
     * Moves the iterator to the first element
     * @param iteratorId Id of the iterator
     * @returns The first element of the iterator
     */
    seekFirst(iteratorId) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.PDOBJECT_SEEK_FIRST;
            request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_ID, iteratorId);
            const response = yield this.connection.sendFullQualified(request);
            if (response.oId === "0:0") {
                return null;
            }
            else {
                const pdObject = new PDObject(this.connection, response.oId);
                return pdObject;
            }
        });
    }
    /**
     * Moves the iterator to the next element
     * @param iteratorId Id of the iterator
     * @returns The next element of the iterator
     */
    seekNext(iteratorId) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.PDOBJECT_SEEK_NEXT;
            request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_ID, iteratorId);
            const response = yield this.connection.sendFullQualified(request);
            if (response.oId === "0:0") {
                return null;
            }
            else {
                const pdObject = new PDObject(this.connection, response.oId);
                return pdObject;
            }
        });
    }
    seekObject(iteratorId, positionOrObject, offset) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.oId = this.oId;
            if (typeof positionOrObject === "number") {
                // move to a given position
                request.operation = SDSMessage_1.Operations.PDOBJECT_SEEK;
                request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_ID, iteratorId);
                request.addParameter(SDSMessage_1.ParameterNames.INDEX, positionOrObject);
                request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_OFFSET, offset);
            }
            else {
                // move to the passed pd object
                request.operation = SDSMessage_1.Operations.PDOBJECT_SEEK_OBJECT;
                request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_ID, iteratorId);
                request.addParameter(SDSMessage_1.ParameterNames.OTHER_OBJECT_ID, positionOrObject.oId);
            }
            const response = yield this.connection.sendFullQualified(request);
            if (response.oId === "0:0") {
                return null;
            }
            else {
                const pdObject = new PDObject(this.connection, response.oId);
                return pdObject;
            }
        });
    }
    /**
     * Sets the value of an attribute
     * @param attributeName Name of the attribute
     * @param attributeValue Value of the attribute
     * @throws Error if the attribute could not be set
     */
    setAttribute(attributeName, attributeValue) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.oId = this.oId;
                request.operation = SDSMessage_1.Operations.PDOBJECT_SETATTRIBUTE;
                request.addParameter(SDSMessage_1.ParameterNames.CLASS_NAME, attributeName);
                request.addParameter(SDSMessage_1.ParameterNames.VALUE, attributeValue);
                const response = yield this.connection.sendSimple(request);
                if (response.result === 0) {
                    resolve();
                }
                else {
                    // see dissertation Niemann, p. 234, Tab. 1.1-5
                    const errorMessageOperation = (response.result < 0) ? this.connection.PDMeta.getString : this.connection.PDMeta.errorMessage;
                    const errorMessage = yield this.getFormattedError(`Can't set attribute '${attributeName}' to '${attributeValue}'`, response.result, errorMessageOperation);
                    throw new Error(errorMessage);
                }
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Starts a new Transaction.
     * @param pdObject
     * @param lockId
     */
    startTransaction(pdObject, lockId) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.oId = this.oId;
            request.operation = SDSMessage_1.Operations.PDOBJECT_START_TRANSACTION;
            request.addParameter(SDSMessage_1.ParameterNames.OTHER_OBJECT_ID, pdObject.oId);
            if (typeof lockId === "number") {
                request.addParameter(SDSMessage_1.ParameterNames.LOCK_GROUP, lockId);
            }
            // Operation gibt "-1" zurück
            yield this.connection.send(request);
        });
    }
    /**
     * Executes a sync to persist changes made on the PDObject
     */
    sync() {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.oId = this.oId;
                request.operation = SDSMessage_1.Operations.PDOBJECT_SYNC;
                // @todo: The sync operation can now not be used to change values of the object,
                // and it seems like this operation doesn't return any value which indicates the failure or success of
                // this operation
                yield this.connection.send(request);
                resolve();
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Executes an operation on the JANUS-server.
     * @param operation Name of the operation
     * @param parameters The parameters of the operation
     * @param parametersPDO TODO
     */
    callOperationInternal(async, operation, parameters, pdObjects) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.oId = this.oId;
                request.operation = (async) ? SDSMessage_1.Operations.PDOBJECT_CALL_ASYNC : SDSMessage_1.Operations.PDOBJECT_CALL_SYNC;
                request.addParameter(SDSMessage_1.ParameterNames.CLASS_NAME, operation);
                let response;
                if (Array.isArray(parameters)) {
                    // note: once the operation is parameterized, the operation code is different!
                    request.operation = (async) ? SDSMessage_1.Operations.PDOBJECT_CALL_ASYNC_PARAMETERIZED : SDSMessage_1.Operations.PDOBJECT_CALL_SYNC_PARAMETERIZED;
                    if (parameters.length > 0) {
                        request.addParameter(SDSMessage_1.ParameterNames.PARAMETER, parameters);
                    }
                    if (Array.isArray(pdObjects) && pdObjects.length > 0) {
                        request.addParameter(SDSMessage_1.ParameterNames.PARAMETER_PDO, pdObjects.map((pdObject) => pdObject.oId));
                    }
                    response = yield this.connection.send(request);
                }
                else {
                    if (async) {
                        response = yield this.connection.send(request);
                    }
                    else {
                        response = yield this.connection.sendSimple(request);
                    }
                }
                if (async) {
                    // the server doesn't wait for the operation to finish
                    // so we have no clue about the success or failure of the execution
                    resolve();
                }
                else {
                    resolve(response);
                }
            }
            catch (err) {
                reject(err);
            }
        }));
    }
}
exports.PDObject = PDObject;
//# sourceMappingURL=PDObject.js.map