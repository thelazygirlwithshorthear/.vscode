"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PDClass = exports.LOCK_MODE = exports.PDIteratorPositions = void 0;
const cryptmd5_1 = require("../cryptmd5");
const SDSMessage_1 = require("../sds/SDSMessage");
const SDSRequest_1 = require("../sds/SDSRequest");
const JANUSClass_1 = require("./JANUSClass");
const PDObject_1 = require("./PDObject");
const unixcrypt_1 = require("unixcrypt");
var PDIteratorPositions;
(function (PDIteratorPositions) {
    /** Move the iterator relative to the first element */
    PDIteratorPositions[PDIteratorPositions["FIRST"] = 1] = "FIRST";
    /** Move the iterator relative to the last element */
    PDIteratorPositions[PDIteratorPositions["LAST"] = 2] = "LAST";
    /** Move the iterator relative to the current position */
    PDIteratorPositions[PDIteratorPositions["CURRENT"] = 3] = "CURRENT";
})(PDIteratorPositions = exports.PDIteratorPositions || (exports.PDIteratorPositions = {}));
var LOCK_MODE;
(function (LOCK_MODE) {
    /** No lock */
    LOCK_MODE[LOCK_MODE["LOCK_NONE"] = 0] = "LOCK_NONE";
    /** Object can't be deleted */
    LOCK_MODE[LOCK_MODE["LOCK_DELETE"] = 1] = "LOCK_DELETE";
    /** Object can't be deleted and relations can't be modified */
    LOCK_MODE[LOCK_MODE["LOCK_RELATION"] = 2] = "LOCK_RELATION";
    /** Object can't be deleted and attributes can't be modified */
    LOCK_MODE[LOCK_MODE["LOCK_ATTRIBUTES"] = 3] = "LOCK_ATTRIBUTES";
    /** Object can't be modified or deleted */
    LOCK_MODE[LOCK_MODE["LOCK_ALL"] = 4] = "LOCK_ALL";
})(LOCK_MODE = exports.LOCK_MODE || (exports.LOCK_MODE = {}));
class PDClass extends JANUSClass_1.JANUSClass {
    constructor(sdsConnection) {
        super(sdsConnection);
        this.userIds = new Map();
    }
    /**
     * Executes an operation on the JANUS-server
     * @todo This function is untested
     * @param operation Name of the operation
     * @param parameters The parameters of the operation
     * @param parametersPDO TODO
     * @returns Execution result of the operation
     */
    callOperation(operation, parameters, pdObjects) {
        return this.callOperationInternal(false, operation, parameters, pdObjects);
    }
    /**
     * Executes an operation on the JANUS-server asynchronously
     * @todo This function is untested
     * @param operation Name of the operation
     * @param parameters The parameters of the operation
     * @param parametersPDO TODO
     */
    callOperationAsync(operation, parameters, pdObjects) {
        return this.callOperationInternal(true, operation, parameters, pdObjects);
    }
    /**
     * Changes the principal which the client is connected to
     * @param principal Name of the principal
     */
    changePrincipal(principal) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.CHANGE_PRINCIPAL;
                request.addParameter(SDSMessage_1.ParameterNames.PRINCIPAL, principal);
                const response = yield this.connection.sendFullQualified(request);
                const result = response.getParameter(SDSMessage_1.ParameterNames.RETURN_VALUE);
                if (result === 0) {
                    resolve();
                }
                else {
                    const errorMessage = yield this.getFormattedError(`Unable to change principal to '${principal}'`, result);
                    throw new Error(errorMessage);
                }
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Changes the user which is logged in
     * @param login Login of the user
     * @param password password of the user or hashed MD5-value of the password
     * @param principal The principal name where the user is registered (needed if you want to change to a fellow)
     * @returns The id of the user
     */
    changeUser(login, password, principal) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                let hashedPassword = (password instanceof cryptmd5_1.Hash)
                    ? password.value
                    :
                        (password === "") // When the password is an empty string, don't hash it
                            ? ""
                            : (0, unixcrypt_1.encrypt)(password, PDClass.JANUS_CRYPTSHA2_SALT);
                if (login !== "admin" && !!principal && !login.endsWith(`.${principal}`)) {
                    login = `${login}.${principal}`;
                }
                let request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.CHANGE_USER;
                request.addParameter(SDSMessage_1.ParameterNames.USER, login);
                request.addParameter(SDSMessage_1.ParameterNames.PASSWORD, hashedPassword);
                let response = yield this.connection.sendFullQualified(request);
                let result = response.getParameter(SDSMessage_1.ParameterNames.RETURN_VALUE);
                if (result === PDClass.JANUS_UNKNOWN_PASSWORD && !(password instanceof cryptmd5_1.Hash)) {
                    hashedPassword = (0, cryptmd5_1.crypt_md5)(password, PDClass.JANUS_CRYPTMD5_SALT).value;
                    request = new SDSRequest_1.SDSRequest();
                    request.operation = SDSMessage_1.Operations.CHANGE_USER;
                    request.addParameter(SDSMessage_1.ParameterNames.USER, login);
                    request.addParameter(SDSMessage_1.ParameterNames.PASSWORD, hashedPassword);
                    response = yield this.connection.sendFullQualified(request);
                    result = response.getParameter(SDSMessage_1.ParameterNames.RETURN_VALUE);
                }
                if (result === 0) {
                    let userId = -1;
                    if (!this.userIds.has(login)) {
                        userId = response.getParameter(SDSMessage_1.ParameterNames.USER_ID);
                        this.userIds.set(login, userId);
                    }
                    else if (this.userIds.has(login)) {
                        userId = this.userIds.get(login);
                    }
                    else {
                        const errorMessage = yield this.getFormattedError("Change user request failed: Could not determine the user id");
                        throw new Error(errorMessage);
                    }
                    resolve(userId);
                }
                else {
                    // Error occurred. Get the error message from the server
                    const errorMessage = yield this.getFormattedError("Change user request failed. Maybe you forgot to provide the principal?", result, this.connection.PDMeta.errorMessage);
                    throw new Error(errorMessage);
                }
            }
            catch (err) {
                reject(err);
            }
        })).then((userId) => __awaiter(this, void 0, void 0, function* () {
            // if a principal is provided, call a change principal request, because the server requires that after a change user request a change principal request will be send
            if (!!principal) {
                yield this.changePrincipal(principal);
            }
            return userId;
        }));
    }
    /**
     * Returns the number of PDObjects of the passed class.
     * @param classIdOrName
     * @param listName
     * @param filter
     * @param pdObject
     */
    countObjects(classIdOrName, listName = "", filter = "") {
        return __awaiter(this, void 0, void 0, function* () {
            const classId = (typeof classIdOrName === "string")
                ? yield this.connection.PDMeta.getClassId(classIdOrName)
                : classIdOrName;
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.PDCLASS_COUNT_OBJECTS;
            request.addParameter(SDSMessage_1.ParameterNames.CLASS_NAME, classId);
            request.addParameter(SDSMessage_1.ParameterNames.LIST_NAME, listName);
            request.addParameter(SDSMessage_1.ParameterNames.SELECT, filter);
            const response = yield this.connection.sendSimple(request);
            if (response.result < 0) {
                const errorMessage = yield this.getFormattedError("Can't count objects", response.result);
                throw new Error(errorMessage);
            }
            else {
                return response.result;
            }
        });
    }
    createLockAndGroup(pdObject, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.oId = pdObject.oId;
            request.operation = SDSMessage_1.Operations.PDCLASS_CREATE_LOCK_AND_GROUP;
            request.addParameter(SDSMessage_1.ParameterNames.LOCK_MODE, mode);
            const response = yield this.connection.sendSimple(request);
            if (response.result < 0) {
                const errorMessage = yield this.getFormattedError("Unable create lock group", response.result);
                throw new Error(errorMessage);
            }
            return response.result;
        });
    }
    /**
     * Creates a principal or modifies the principal, if it already exist
     * @param principal Technical name of the principal
     * @param longName Description of the principal
     * @param users Users which should be assigned to the principal
     */
    createOrChangePrincipal(principal, longName, users = []) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.CREATE_OR_CHANGE_PRINCIPAL;
                request.addParameter(SDSMessage_1.ParameterNames.PRINCIPAL, principal);
                request.addParameter(SDSMessage_1.ParameterNames.FULL_NAME, longName);
                request.addParameter(SDSMessage_1.ParameterNames.USERS, users);
                const response = yield this.connection.sendSimple(request);
                if (response.result === 0) {
                    resolve();
                }
                else {
                    const errorMessage = yield this.getFormattedError(`Can't create or change principal '${principal}'`, response.result);
                    throw new Error(errorMessage);
                }
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Creates or modifies an user
     * Note: If you want to create an user for a principal, execute a 'changePrincipal' before using this function
     * @param login Login of the user
     * @param fullName Full name of the user
     * @param password Password of the user (not crypted). If the user has no password, pass an empty string. If the password of an existing user should not be changed, pass null
     * @param passExpire Expiration date of the password. This term will be restarted after the user changes his password
     * @param accountExpire Expiration date of the user account
     * @returns The id of the user
     * @example
     * await sdsConnection.PDClass.changePrincipal("principal");
     * await sdsConnection.PDClass.createOrChangeUser("user", "full name", "secret password", new Date());
     */
    createOrChangeUser(login, fullName, password, passExpire, accountExpire) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.PDCLASS_NEWUSER;
                request.addParameter(SDSMessage_1.ParameterNames.USER, login);
                request.addParameter(SDSMessage_1.ParameterNames.FULL_NAME, fullName);
                if (password) {
                    request.addParameter(SDSMessage_1.ParameterNames.PASSWORD, (0, cryptmd5_1.crypt_md5)(password, PDClass.JANUS_CRYPTMD5_SALT).value);
                }
                else {
                    request.addParameter(SDSMessage_1.ParameterNames.PASSWORD, 0);
                }
                request.addParameter(SDSMessage_1.ParameterNames.PASSWORD_EXPIRE, passExpire.getTime());
                if (accountExpire) {
                    request.addParameter(SDSMessage_1.ParameterNames.ACCOUNT_EXPIRE, accountExpire.getTime());
                }
                // is the password encrypted?
                request.addParameter(SDSMessage_1.ParameterNames.SOMETHING, true);
                const response = yield this.connection.sendFullQualified(request);
                const userId = response.getParameter(SDSMessage_1.ParameterNames.USER_ID);
                if (userId < 0) {
                    const errorMessage = yield this.getFormattedError(`Can't create user '${login}'`, userId, this.connection.PDMeta.errorMessage);
                    throw new Error(errorMessage);
                }
                else {
                    resolve(userId);
                }
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Removes an open iterator
     * @param iteratorId
     */
    deleteIterator(iteratorId) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.PDCLASS_DELETE_ITERATOR;
            request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_ID, iteratorId);
            // Operation returns "-1" in case of success
            yield this.connection.send(request);
        });
    }
    /**
     * Deletes an object
     * @param object PD Object which should be deleted
     */
    deleteObject(object, lockId) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.PDCLASS_DELETE_OBJECT;
            request.oId = object.oId;
            if (typeof lockId === "number") {
                request.addParameter(SDSMessage_1.ParameterNames.LOCK_GROUP, lockId);
            }
            // Operation returns "-1" in case of success
            const response = yield this.connection.sendSimple(request);
            if (response.result !== 0) {
                const errorMessage = yield this.getFormattedError(`Could not delete PDObject '${object.oId}'`, response.result);
                throw new Error(errorMessage);
            }
        });
    }
    /**
     * Logout from server.
     * Do not wait for response, connection will be closed.
     */
    disconnectClient() {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.PDCLASS_DISCONNECT_CLIENT;
                // no response, the connection will be closed immediately
                this.connection.disconnectPromiseResolve = resolve;
                yield this.connection.send(request, false);
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Returns the numeric id of the principal
     * @param principalName Name (id) of the principal
     */
    getPrincipalId(principalName) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.PDCLASS_GET_PRINCIPAL_ID;
            request.addParameter(SDSMessage_1.ParameterNames.PRINCIPAL, principalName);
            const result = yield this.connection.send(request);
            const id = result.getParameter(SDSMessage_1.ParameterNames.PRINCIPAL_ID);
            return id;
        });
    }
    /**
     * Returns true if the iterator points not to the last element of the iterator
     * @param iteratorId Id of the iterator
     */
    hasNext(iteratorId) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.PDCLASS_HAS_NEXT;
                request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_ID, iteratorId);
                const response = yield this.connection.sendSimple(request);
                const hasNext = (response.result === 1);
                resolve(hasNext);
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Returns true if the iterator points not to the first element of the iterator
     * @param iteratorId Id of the Iterator
     */
    hasPrev(iteratorId) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.PDCLASS_HAS_PREVIOUS;
                request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_ID, iteratorId);
                const response = yield this.connection.sendSimple(request);
                const hasNext = (response.result === 1);
                resolve(hasNext);
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Creates a new PDIterator
     * @param className Class name of the objects to iterate on
     * @param filter Filter criteria
     * @param sort Sort criteria
     * @param pdObject PDObject the objects are related to
     * @param listName User defined list name to iterate on
     * @returns The id of the iterator
     */
    newIterator(className, filter = null, sort = null, pdObject, listName = null) {
        return new Promise((resolve, reject) => __awaiter(this, arguments, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.PDCLASS_NEW_ITERATOR;
                if (pdObject) {
                    request.oId = pdObject.oId;
                }
                const classId = (typeof className === "number")
                    ? className
                    : yield this.connection.PDMeta.getClassId(className);
                request.addParameter(SDSMessage_1.ParameterNames.CLASS_NAME, classId);
                request.addParameter(SDSMessage_1.ParameterNames.LIST_NAME, listName);
                request.addParameter(SDSMessage_1.ParameterNames.SELECT, filter);
                request.addParameter(SDSMessage_1.ParameterNames.SORT_EXPRESSION, sort);
                const response = yield this.connection.sendSimple(request);
                if (response.result < 0) {
                    // eslint-disable-next-line prefer-rest-params
                    const errorMessage = yield this.getFormattedError(`Iterator instantiation failed. Arguments: ${JSON.stringify(arguments)}`);
                    throw new Error(errorMessage);
                }
                resolve(response.result);
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    newLockGroup() {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new SDSRequest_1.SDSRequest();
            request.operation = SDSMessage_1.Operations.NEW_LOCK_GROUP;
            const response = yield this.connection.sendSimple(request);
            if (response.result < 0) {
                const errorMessage = yield this.getFormattedError("Unable create lock group", response.result);
                throw new Error(errorMessage);
            }
            return response.result;
        });
    }
    /**
     * Creates a instance of a given class
     * @param className Class name to create an instance of
     * @param isTransactionObject Specifies if the object is a transaction object
     * @param initDefaults Specifies if default values should be initialized
     */
    newObject(className, isTransactionObject = false, initDefaults = true) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.PDCLASS_NEWOBJECT;
                request.addParameter(SDSMessage_1.ParameterNames.IS_TRANSACTION_OBJECT, isTransactionObject);
                request.addParameter(SDSMessage_1.ParameterNames.INIT, initDefaults);
                const classId = yield this.connection.PDMeta.getClassId(className); // classes and class names are cached, so this causes no performance issues
                request.addParameter(SDSMessage_1.ParameterNames.CLASS_ID, classId);
                const response = yield this.connection.sendFullQualified(request);
                if (response.oId === "0:0") {
                    // error occurred
                    const result = response.getParameter(SDSMessage_1.ParameterNames.RETURN_VALUE);
                    const errorMessage = yield this.getFormattedError(`Unable to create object of class '${className}'`, result);
                    throw new Error(errorMessage);
                }
                else {
                    const pdObject = new PDObject_1.PDObject(this.connection, response.oId, classId, className);
                    resolve(pdObject);
                }
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Fetches the object by its id
     * @param oId Id of the object
     * @returns The object with the passed id
     */
    ptr(oId) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.PDCLASS_PTR;
                request.oId = oId;
                const response = yield this.connection.sendFullQualified(request);
                if (response.oId === "0:0") {
                    // the object doesn't exists
                    throw new Error(`The object with id '${oId}' does not exists`);
                }
                else {
                    const pdObject = new PDObject_1.PDObject(this.connection, oId);
                    resolve(pdObject);
                }
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Moves the iterator to the first element
     * @param iteratorId Id of the iterator
     * @returns The first element of the iterator
     */
    seekFirst(iteratorId) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.PDCLASS_SEEK_FIRST;
                request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_ID, iteratorId);
                const response = yield this.connection.sendFullQualified(request);
                if (response.oId === "0:0") {
                    resolve(null);
                }
                else {
                    const pdObject = new PDObject_1.PDObject(this.connection, response.oId);
                    resolve(pdObject);
                }
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Moves the iterator to the next element
     * @param iteratorId Id of the iterator
     * @returns The next element of the iterator
     */
    seekNext(iteratorId) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = SDSMessage_1.Operations.PDCLASS_SEEK_NEXT;
                request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_ID, iteratorId);
                const response = yield this.connection.sendFullQualified(request);
                if (response.oId === "0:0") {
                    resolve(null);
                }
                else {
                    const pdObject = new PDObject_1.PDObject(this.connection, response.oId);
                    resolve(pdObject);
                }
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    seekObject(iteratorId, positionOrObject, offset = PDIteratorPositions.CURRENT) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                if (typeof positionOrObject === "number") {
                    // move to a given position
                    request.operation = SDSMessage_1.Operations.PDCLASS_SEEK;
                    request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_ID, iteratorId);
                    request.addParameter(SDSMessage_1.ParameterNames.INDEX, positionOrObject);
                    request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_OFFSET, offset);
                }
                else {
                    // move to the passed pd object
                    request.operation = SDSMessage_1.Operations.PDCLASS_SEEK_OBJECT;
                    request.addParameter(SDSMessage_1.ParameterNames.ITERATOR_ID, iteratorId);
                    request.oId = (!!positionOrObject) ? positionOrObject.oId : "0:0"; // can be null
                }
                const response = yield this.connection.sendFullQualified(request);
                if (response.oId === "0:0") {
                    resolve(null);
                }
                else {
                    const pdObject = new PDObject_1.PDObject(this.connection, response.oId);
                    resolve(pdObject);
                }
            }
            catch (err) {
                reject(err);
            }
        }));
    }
    /**
     * Executes an operation on the JANUS-server.
     * @param operation Name of the operation
     * @param parameters The parameters of the operation
     * @param parametersPDO TODO
     */
    callOperationInternal(async, operation, parameters, pdObjects) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const request = new SDSRequest_1.SDSRequest();
                request.operation = (async) ? SDSMessage_1.Operations.PDCLASS_CALL_ASYNC : SDSMessage_1.Operations.PDCLASS_CALL_SYNC;
                request.addParameter(SDSMessage_1.ParameterNames.CLASS_NAME, operation);
                let response;
                if (Array.isArray(parameters)) {
                    // note: once the operation is parameterized, the operation code is different!
                    request.operation = (async) ? SDSMessage_1.Operations.PDCLASS_CALL_ASYNC_PARAMETERIZED : SDSMessage_1.Operations.PDCLASS_CALL_SYNC_PARAMETERIZED;
                    if (parameters.length > 0) {
                        request.addParameter(SDSMessage_1.ParameterNames.PARAMETER, parameters);
                    }
                    if (Array.isArray(pdObjects) && pdObjects.length > 0) {
                        request.addParameter(SDSMessage_1.ParameterNames.PARAMETER_PDO, pdObjects.map((pdObject) => pdObject.oId));
                    }
                    response = yield this.connection.send(request);
                }
                else {
                    if (async) {
                        response = yield this.connection.send(request);
                    }
                    else {
                        response = yield this.connection.sendSimple(request);
                    }
                }
                if (async) {
                    // the server doesn't wait for the operation to finish
                    // so we have no clue about the success or failure of the execution
                    resolve();
                }
                else {
                    resolve(response);
                }
            }
            catch (err) {
                reject(err);
            }
        }));
    }
}
exports.PDClass = PDClass;
/** Salt for hashing passwords before sending them to the JANUS-server */
PDClass.JANUS_CRYPTMD5_SALT = "o3";
PDClass.JANUS_CRYPTSHA2_SALT = "$6$o3";
PDClass.JANUS_UNKNOWN_PASSWORD = 22;
//# sourceMappingURL=PDClass.js.map