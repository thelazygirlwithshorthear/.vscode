"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = exports.LogLevelFromString = exports.LogLevel = void 0;
const fs = require("fs");
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
    LogLevel[LogLevel["None"] = 4] = "None";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
function LogLevelFromString(logLevelString) {
    switch (logLevelString) {
        case 'Debug':
            return LogLevel.Debug;
        case 'Info':
            return LogLevel.Info;
        case 'Warn':
            return LogLevel.Warn;
        case 'Error':
            return LogLevel.Error;
        case 'None':
            return LogLevel.None;
        default:
            throw new Error("${logLevelString} cannot be translated to a LogLevel");
    }
}
exports.LogLevelFromString = LogLevelFromString;
class Logger {
    static create(name) {
        return new Logger(name);
    }
    constructor(name) {
        this.name = name;
        this.logLevel = LogLevel.None;
        this.configure();
        Logger.loggers.set(name, this);
    }
    debug(msg) { this.log(LogLevel.Debug, 'DEBUG', msg); }
    info(msg) { this.log(LogLevel.Info, 'INFO', msg); }
    warn(msg) { this.log(LogLevel.Warn, 'WARN', msg); }
    error(msg) { this.log(LogLevel.Error, 'ERROR', msg); }
    static set config(newConfig) {
        if (Logger.fd !== undefined) {
            fs.closeSync(Logger.fd);
            Logger.fd = undefined;
        }
        Logger._config = newConfig;
        if (Logger._config.fileName) {
            try {
                Logger.fd = fs.openSync(Logger._config.fileName, 'w');
            }
            catch (err) {
                // Swallow
            }
        }
        Logger.loggers.forEach(logger => logger.configure());
    }
    log(level, displayLevel, msg) {
        if (level < this.logLevel) {
            return;
        }
        const elapsedTime = (Date.now() - Logger.startTime) / 1000;
        let elapsedTimeString = elapsedTime.toFixed(3);
        while (elapsedTimeString.length < 9) {
            elapsedTimeString = '0' + elapsedTimeString;
        }
        while (displayLevel.length < 5) {
            displayLevel = displayLevel + ' ';
        }
        const logLine = displayLevel + '|' + elapsedTimeString + '|' + this.name + ': ' + msg;
        if ((Logger.fd !== undefined)) {
            fs.writeSync(Logger.fd, logLine + '\n');
        }
    }
    configure() {
        if (Logger._config.fileName && Logger._config.logLevel) {
            try {
                this.logLevel = Logger._config.logLevel[this.name];
            }
            catch (err) {
                // tslint:disable-next-line:no-string-literal
                this.logLevel = Logger._config.logLevel['default'];
                throw err;
            }
        }
        else {
            this.logLevel = LogLevel.Debug;
        }
    }
}
exports.Logger = Logger;
Logger.loggers = new Map();
Logger._config = {};
Logger.startTime = Date.now();
//# sourceMappingURL=log.js.map