"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getScriptsFromFolderSync = exports.readDirSync = exports.saveScriptUpdateSyncHash = exports.writeFileEnsureDir = exports.runAll = exports.debugScript = exports.runScript = exports.uploadScripts = exports.uploadScript = exports.downloadAll = exports.downloadScript = exports.getSystemUser = exports.getScriptInfoAsJSONAll = exports.getFileTypesTSD = exports.getFileTypeInterface = exports.getFileTypeNames = exports.getScriptNamesWithModesFromServer = exports.getScriptNamesFromServer = exports.getScriptsFromServer = exports.updateScriptLibs = exports.updateDocuments = exports.receiveFiles = exports.exportXML = exports.importXML = exports.clearPortalScriptCache = exports.getProperty = exports.getDocumentsVersion = exports.doMaintenance = exports.getSourceCodeForEditor = exports.setScriptMode = exports.getScriptMode = exports.callClassOperation = exports.disconnect = exports.connectLogin = exports.serverSession = exports.xmlExport = exports.scriptT = exports.CONFLICT_CATEGORY = exports.CONFLICT_SOURCE_CODE = exports.VERSION_MODULE_SCRIPT = exports.VERSION_SHOW_IMPORTS = exports.VERSION_PARAMS_SET = exports.VERSION_FIELD_TYPES = exports.VERSION_CATEGORIES = exports.VERSION_ENCRYPTION = exports.VERSION_PARAMS_GET = exports.VERSION_MIN = void 0;
const os = require("os");
const path = require("path");
const crypto = require("crypto");
const sds = require("@otris/node-sds");
const node_sds_1 = require("@otris/node-sds");
const reduce = require("reduce-for-promises");
const fs = require("fs-extra");
// const sds = require("@otris/node-sds");
// const ParameterNames = sds.ParameterNames;
// export type SDSConnection = any;
// export type SDSResponse = any;
exports.VERSION_MIN = "8034";
exports.VERSION_PARAMS_GET = "8036";
exports.VERSION_ENCRYPTION = "8040";
exports.VERSION_CATEGORIES = "8041";
exports.VERSION_FIELD_TYPES = "8044";
exports.VERSION_PARAMS_SET = "8067";
exports.VERSION_SHOW_IMPORTS = "8047";
exports.VERSION_MODULE_SCRIPT = "8502";
exports.CONFLICT_SOURCE_CODE = 0x1;
exports.CONFLICT_CATEGORY = 0x2;
const SDS_DEFAULT_TIMEOUT = 60 * 1000;
const ERROR_DECRYPT_PERMISSION = "For downloading encrypted scripts the decryption PEM file is required";
const ERROR_SOURCE_MISSING = "Source code missing in script";
class scriptT {
    constructor(name, path, localCode) {
        /**
         * Internal flag.
         */
        this.allowDownloadEncrypted = false;
        /**
         * Default: true
         *
         * If the function 'uploadScript' is called with a script in conflict
         * mode, the hash value is used to check, if the source code of the
         * script on server has changed since last up- or download.
         *
         * If a script in conflict mode was changed on server, it won't
         * be uploaded, instead the member 'conflict' will be set to true.
         */
        this.conflictMode = true;
        /**
         * Bit pattern.
         *
         * CONFLICT_SOURCE_CODE is set, if uploadScript was called for this script,
         * but the source code of the script on server has been changed since
         * last up- or download.
         *
         * CONFLICT_CATEGORY is set, if uploadScript was called for this script,
         * but the category is different on server.
         */
        this.conflict = 0x0;
        this.mode = "Classic";
        this.name = name;
        if (path) {
            this.path = path;
        }
        if (localCode) {
            this.localCode = localCode;
        }
    }
}
exports.scriptT = scriptT;
class xmlExport {
    constructor(className, filter, fileName, content, files) {
        this.className = className;
        this.filter = filter;
        this.fileName = fileName;
        this.content = content;
        this.files = files;
    }
}
exports.xmlExport = xmlExport;
/**
 * This function establishes a connection to the server, calls the given operation
 * and closes the connection. All available operations are implemented below.
 *
 * @param loginData
 * @param param input parameter of the operation
 * @param serverOperation the operation to be called on server
 */
function serverSession(loginData, param, serverOperation) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            // create connection
            let sdsConnection = new sds.SDSConnection();
            try {
                yield connectLogin(sdsConnection, loginData);
                // get/check version
                const value = yield getDocumentsVersion(sdsConnection, [exports.VERSION_MIN]);
                loginData.documentsVersion = value[0];
                // set language
                if (loginData.language > 0) {
                    yield sdsConnection.PDMeta.setLanguage(loginData.language);
                }
                if (serverOperation === undefined) {
                    return resolve([]);
                }
                // call function
                const result = yield serverOperation(sdsConnection, param, loginData);
                return resolve(result);
            }
            catch (err) {
                return reject(err);
            }
            finally {
                disconnect(sdsConnection);
            }
        }));
    });
}
exports.serverSession = serverSession;
function connectLogin(sdsConnection, conn) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            let connection = sdsConnection;
            if (connection === undefined) {
                connection = new sds.SDSConnection();
            }
            if (connection.isConnected) {
                return resolve(connection);
            }
            if (conn.password === undefined) {
                return reject("Cannot login, password must be Hash or empty string");
            }
            try {
                // connect/login
                sds.SDSConnection.TIMEOUT = conn.sdsTimeout ? conn.sdsTimeout : sds.SDSConnection.TIMEOUT;
                // sds.SDSConnection.STREAMING_TIMEOUT = 10000000;
                yield connection.connect(conn.clientName ? conn.clientName : "node-documents-scripting", conn.server, conn.port, conn.tls, conn.startTls, conn.trustedCas);
            }
            catch (err) {
                return reject(err);
            }
            try {
                yield connection.PDClass.changeUser(conn.username, conn.password);
            }
            catch (err) {
                conn.password = undefined;
                return reject(err);
            }
            try {
                yield connection.PDClass.changePrincipal(conn.principal);
            }
            catch (err) {
                return reject(err);
            }
            return resolve(connection);
        }));
    });
}
exports.connectLogin = connectLogin;
function disconnect(sdsConnection) {
    sdsConnection.disconnect();
}
exports.disconnect = disconnect;
function callClassOperation(sdsConnection, op, params) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield sdsConnection.PDClass.callOperation(op, params);
                const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
                if (errCode < 0) {
                    const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                    return reject(value[0]);
                }
                const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                return resolve(value);
            }
            catch (err) {
                return reject(`${op} failed: ` + err);
            }
        }));
    });
}
exports.callClassOperation = callClassOperation;
function getScriptMode(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        if (Number(connInfo.documentsVersion) < Number(exports.VERSION_MODULE_SCRIPT))
            return ["Classic"];
        const scriptName = params[0];
        const scriptIter = yield sdsConnection.PDClass.newIterator("PortalScript", `Name='${scriptName}'`);
        if (!scriptIter)
            throw new Error("Script not found!");
        const script = yield sdsConnection.PDClass.seekNext(scriptIter);
        yield sdsConnection.PDClass.deleteIterator(scriptIter);
        if (!script)
            throw new Error("Script not found!");
        const scriptMode = yield script.getAttribute("ScriptMode.Tech");
        if (scriptMode !== "Classic" && scriptMode !== "Module")
            throw new Error("Unexpected ScriptMode!");
        return [scriptMode];
    });
}
exports.getScriptMode = getScriptMode;
function setScriptMode(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        if (Number(connInfo.documentsVersion) < Number(exports.VERSION_MODULE_SCRIPT))
            throw new Error("ScriptMode only available with Documents6");
        const scriptName = params[0];
        const scriptMode = params[1];
        if (scriptMode !== "Classic" && scriptMode !== "Module")
            throw new Error("Unexpected ScriptMode!");
        const scriptIter = yield sdsConnection.PDClass.newIterator("PortalScript", `Name='${scriptName}'`);
        if (!scriptIter)
            throw new Error("Script not found!");
        const script = yield sdsConnection.PDClass.seekNext(scriptIter);
        yield sdsConnection.PDClass.deleteIterator(scriptIter);
        if (!script)
            throw new Error("Script not found!");
        yield script.setAttribute("ScriptMode.Tech", scriptMode);
        return [];
    });
}
exports.setScriptMode = setScriptMode;
function getSourceCodeForEditor(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            if (Number(connInfo.documentsVersion) < Number(exports.VERSION_SHOW_IMPORTS)) {
                return reject(`For operation PortalScript.getSourceCodeForEditor at least DOCUMENTS ${exports.VERSION_SHOW_IMPORTS} is required`);
            }
            try {
                const value = yield callClassOperation(sdsConnection, "PortalScript.getSourceCodeForEditor", params);
                return resolve(value);
            }
            catch (err) {
                return reject(err);
            }
        }));
    });
}
exports.getSourceCodeForEditor = getSourceCodeForEditor;
function doMaintenance(sdsConnection, params) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield callClassOperation(sdsConnection, "Global.doMaintenance", params);
    });
}
exports.doMaintenance = doMaintenance;
/**
 * @param params if params[0] contains a number (e.g. "8034"), the version is checked against this number
 */
function getDocumentsVersion(sdsConnection, params) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const value = yield callClassOperation(sdsConnection, "PartnerNet.getVersionNo", []);
            if (params.length > 0) {
                const version = value[0];
                if (!version) {
                    // "PartnerNet.getVersionNo" is available on DOCUMENTS but most likely
                    // not on other JANUS based applications
                    return reject(`This command is only available on DOCUMENTS`);
                }
                else if (Number(version) < Number(params[0])) {
                    return reject(`Current DOCUMENTS build no: ${version} Required DOCUMENTS build no: ${params[0]}`);
                }
            }
            return resolve(value);
        }));
    });
}
exports.getDocumentsVersion = getDocumentsVersion;
/**
 * @param params e.g. ["allowDecryption"] shows if user has permission to decrypt scripts (returns ["1"] for true)
 */
function getProperty(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield callClassOperation(sdsConnection, "PartnerNet.getProperty", params);
    });
}
exports.getProperty = getProperty;
function clearPortalScriptCache(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield callClassOperation(sdsConnection, "PartnerNet.*clearPortalScriptCache", []);
    });
}
exports.clearPortalScriptCache = clearPortalScriptCache;
/**
 * @returns string[]: [json, msg, oid1, attr1, local1 (rel), oid2, ...]
 */
function importXML(sdsConnection, params) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield callClassOperation(sdsConnection, "Global.importXML2", params);
    });
}
exports.importXML = importXML;
/**
 * Generate xml for filetypes or portal scripts
 * Some examples for params:
 * ["DlcFileType", "Title='crmNote'"],
 * ["PortalScript", "Name='myScript'"],
 * ["DlcFileType", ""],
 * ["PortalScript", ""]
 * ["DlcFileType", "(Title='crmNote'||Title='crmCase')"]
 *
 * @param params string array with two entries, class name and filter. See examples in description.
 * @return string array, first element is the xml as string, second to n-th value is the paths to the blobs
 */
function exportXML(sdsConnection, params) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                for (const current of params) {
                    const returnValue = yield callClassOperation(sdsConnection, "Global.exportXML", [current.className, current.filter]);
                    current.content = returnValue[0];
                    current.files = returnValue.slice(1);
                }
            }
            catch (reason) {
                return reject(reason);
            }
            return resolve([]);
        }));
    });
}
exports.exportXML = exportXML;
/**
 * @param files string array containing file paths, like [local1, remote1, ...]
 */
function receiveFiles(sdsConnection, files) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            if ((files.length % 2) !== 0) {
                return reject(`Unexpected length of file array ${files.length}`);
            }
            // tslint:disable-next-line: prefer-for-of
            for (let i = 0; i < files.length - 1; i += 2) {
                try {
                    fs.ensureDirSync(path.dirname(files[i]));
                    // receiveFile(remote, local)
                    yield sdsConnection.PDTools.receiveFile(files[i + 1], files[i]);
                }
                catch (err) {
                    return reject(`Error in receiving file ${files[i + 1]}: ${err}`);
                }
            }
            return resolve([]);
        }));
    });
}
exports.receiveFiles = receiveFiles;
/**
 * @param param [oid1, attr1, local1 (abs), oid2, ...]
 */
function updateDocuments(sdsConnection, param) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            if ((param.length % 3) !== 0) {
                return reject(`Unexpected length of parameter array ${param.length}`);
            }
            try {
                for (let i = 0; (i + 2) < param.length; i = i + 3) {
                    const pdo = yield sdsConnection.PDClass.ptr(param[i + 0]);
                    const remoteDir = yield pdo.getAttribute(param[i + 1] + ".BaseDirOnServer");
                    const remote = path.join(remoteDir, path.basename(param[i + 2]));
                    const remoteNew = yield sdsConnection.PDTools.sendFile(remote, param[i + 2], false);
                    if (remoteNew !== remote) {
                        throw new Error(`server created new name in sendFile ${remoteNew}`);
                    }
                    yield pdo.setAttribute(param[i + 1], path.basename(remoteNew));
                    yield pdo.sync();
                }
            }
            catch (err) {
                return reject(`Error in updateDocument: ${err}`);
            }
            return resolve([]);
        }));
    });
}
exports.updateDocuments = updateDocuments;
/**
 * Load scripts to scriptlibs folder and make server using them by clearing cache
 */
function updateScriptLibs(sdsConnection, param) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            if ((param.length % 2) !== 0) {
                return reject(`Unexpected length of parameter array ${param.length}`);
            }
            try {
                for (let i = 0; (i + 1) < param.length; i = i + 2) {
                    const remote = param[i + 0];
                    const local = param[i + 1];
                    if (remote.indexOf("scriptlibs") < 0) {
                        throw new Error(`remote path must contain scriptlibs folder: ${remote}`);
                    }
                    const remoteNew = yield sdsConnection.PDTools.sendFile(remote, local, false);
                    if (remoteNew !== remote) {
                        throw new Error(`server created new name in sendFile ${remoteNew}`);
                    }
                }
                yield callClassOperation(sdsConnection, "PartnerNet.*clearPortalScriptCache", []);
            }
            catch (err) {
                return reject(`Error in updateDocument: ${err}`);
            }
            return resolve([]);
        }));
    });
}
exports.updateScriptLibs = updateScriptLibs;
/**
 * Get all script names on server as scripts.
 *
 * @param sdsConnection
 * @param params category If set, script names from this category are returned.
 * @returns {scriptT[]} List of scripts created from all script names in category or all script names on server.
 */
function getScriptsFromServer(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        let scripts = [];
        let scriptNamesWithModes = [];
        if (Number(connInfo.documentsVersion) >= Number(exports.VERSION_MODULE_SCRIPT))
            scriptNamesWithModes = yield getScriptNamesWithModesFromServer(sdsConnection, params, connInfo);
        else
            scriptNamesWithModes = yield getScriptNamesFromServer(sdsConnection, params, connInfo);
        for (var i = 0; i < scriptNamesWithModes.length; i++) {
            var script = new scriptT(scriptNamesWithModes[i], "");
            if (Number(connInfo.documentsVersion) >= Number(exports.VERSION_MODULE_SCRIPT)) {
                i++;
                script.mode = scriptNamesWithModes[i];
            }
            scripts.push(script);
        }
        return scripts;
    });
}
exports.getScriptsFromServer = getScriptsFromServer;
/**
 * Get names of all scripts on server.
 *
 * @param sdsConnection
 * @param params category If set, script names from this category are returned.
 * @returns {string[]} List of script names from all scripts on server or in category.
 */
function getScriptNamesFromServer(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        const returnValue = yield sdsConnection.PDClass.callOperation('PortalScript.getScriptNames', params);
        const response = returnValue;
        const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
        if (errCode < 0) {
            const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
            throw new Error("getScriptNamesFromServer failed: " + value[0]);
        }
        const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
        return value;
    });
}
exports.getScriptNamesFromServer = getScriptNamesFromServer;
/**
 * Get names and modes of all scripts on server.
 *
 * @param sdsConnection
 * @param params category If set, script names from this category are returned.
 * @returns {string[]} List of script names and modes from all scripts on server or in category.
 */
function getScriptNamesWithModesFromServer(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        const returnValue = yield sdsConnection.PDClass.callOperation('IPortalScript.getScriptNamesWithModes', params.length ? params : [""]);
        const response = returnValue;
        const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
        if (errCode < 0) {
            const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
            throw new Error("getScriptNamesWithModesFromServer failed: " + value[0]);
        }
        const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
        // omit first value
        return (value && value.length > 1) ? value.slice(1) : [];
    });
}
exports.getScriptNamesWithModesFromServer = getScriptNamesWithModesFromServer;
/**
 * @param params empty for now, later: the categories
 * @return string array containing all filetype names
 */
function getFileTypeNames(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            sdsConnection.PDClass.callOperation('IDlcFileType.getFileTypeNames', []).then((returnValue) => {
                const response = returnValue;
                const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
                if (errCode < 0) {
                    const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                    return reject(value[0]);
                }
                const fileTypeNames = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                // first entry contains the error message that is read in node-sds
                fileTypeNames.splice(0, 1);
                resolve(fileTypeNames);
            }).catch((reason) => {
                reject('getFileTypeNames failed: ' + reason);
            });
        });
    });
}
exports.getFileTypeNames = getFileTypeNames;
/**
 * Get field names of a filetype and create interface declaration for TypeScript
 * definition file.
 *
 * @param sdsConnection
 * @param params the file type
 *
 * @return string containing the interface declaration for the file type
 */
function getFileTypeInterface(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            // check parameter
            if (!params || 0 >= params.length || 0 >= params[0].length) {
                return reject('wrong parameter in getFileTypeInterface');
            }
            const fileTypeName = params[0];
            let operation = 'getFieldNames';
            // older documents versions include a
            // function that also returns the types
            const fieldTypesVersion = checkVersion(connInfo, exports.VERSION_FIELD_TYPES, "VERSION_FIELD_TYPES");
            if (fieldTypesVersion) {
                operation = 'getFieldNamesAndTypes';
            }
            // get the field names
            sdsConnection.PDClass.callOperation('IDlcFileType.' + operation, [fileTypeName]).then((returnValue) => __awaiter(this, void 0, void 0, function* () {
                const response = returnValue;
                const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
                if (errCode < 0) {
                    const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                    return reject(value[0]);
                }
                const fieldInfo = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                let fieldName = '';
                let fieldType = '';
                let output = `declare interface ${fileTypeName}Fields {` + os.EOL;
                let fieldParams = '';
                const steps = fieldTypesVersion ? 2 : 1;
                const length = fieldTypesVersion ? fieldInfo.length - 1 : fieldInfo.length;
                // fieldNames[0] contains error message, that is read in node-sds
                const referenceFileFieldNames = new Map();
                for (let i = 1; i < length; i += steps) {
                    fieldName = fieldInfo[i];
                    fieldType = fieldTypesVersion ? convertDocumentsFieldType(fieldInfo[i + 1]) : 'any';
                    output += `\t${fieldName}: ${fieldType};` + os.EOL;
                    fieldParams += `'${fieldName}' | `;
                    if (fieldInfo[i + 1] === "Reference") {
                        // try to get the referenced file type of the reference fields
                        // the enum value of a reference field always starts with `<fileTypeName>.<identifier>`.
                        // we can extract the file type name by parsing the enum value
                        const enumValues = yield sdsConnection.CustomOperations.runScriptOnServer(`context.changeScriptUser(DlcGlobalOptions.getAttribute("StandardUser"));return context.getEnumValues("${fileTypeName}", "${fieldName}")`);
                        let referenceFileType = "DocFile"; // in case if the enum value cannot be parsed
                        if (!enumValues.match(/error/i)) {
                            // enumValues === <fileTypeName.identifier> , %autotext%
                            const tmp = enumValues.split(/\r?\n|,\s?/)[0].match(/(%[^%]+%)?([^.]+)/);
                            if (!tmp)
                                return reject();
                            referenceFileType = tmp[0];
                            if (referenceFileType.startsWith("%")) {
                                // can contain autotext, like %eDossierType.key%Dossier. Prevent invalid tsd
                                referenceFileType = JSON.stringify(referenceFileType);
                            }
                        }
                        referenceFileFieldNames.set(fieldName, referenceFileType);
                    }
                }
                if (fieldParams.length > 0) {
                    // remove last ' |' in parameters for get/setFieldValues
                    fieldParams = fieldParams.substr(0, fieldParams.length - 3);
                }
                output += `}` + os.EOL;
                output += os.EOL;
                // Get all Registers
                const registerNames = yield getRegisterNames(fileTypeName, sdsConnection);
                output += `declare type ${fileTypeName}RegisterNames = "${registerNames.join("\"|\"")}";${os.EOL}`;
                output += os.EOL;
                output += `declare interface ${fileTypeName} extends DocFile, ${fileTypeName}Fields {`;
                if (fieldParams.length > 0) {
                    // add functions getFieldValue and setFieldValue
                    output += `${os.EOL}\tsetFieldValue(fieldName: keyof ${fileTypeName}Fields, value: any): boolean;` + os.EOL;
                    output += `\tgetFieldValue(fieldName: keyof ${fileTypeName}Fields): any;` + os.EOL;
                    if (referenceFileFieldNames.size > 0) {
                        output += `\tgetReferenceFile<K extends keyof ${fileTypeName}ReferenceFiles>(fieldName: K): ${fileTypeName}ReferenceFiles[K];` + os.EOL;
                        output += `\tsetReferenceFile<K extends keyof ${fileTypeName}ReferenceFiles>(fieldName: K, referenceFile: ${fileTypeName}ReferenceFiles[K]): boolean;` + os.EOL;
                    }
                }
                if (registerNames.length > 0) {
                    output += `\tgetRegisterByName(registerName: ${fileTypeName}RegisterNames, checkAccessRight?: boolean): Register;` + os.EOL;
                }
                output += `}${os.EOL}`;
                if (referenceFileFieldNames.size > 0) {
                    output += `${os.EOL}declare interface ${fileTypeName}ReferenceFiles {${os.EOL}`;
                    for (const [fieldName, referenceFileTypeName] of referenceFileFieldNames) {
                        output += `\t"${fieldName}": ${referenceFileTypeName};${os.EOL}`;
                    }
                    output += `}${os.EOL}${os.EOL}`;
                }
                resolve([output, registerNames]);
            })).catch((reason) => {
                reject('IDlcFileType.getFieldNames failed: ' + reason);
            });
        });
    });
}
exports.getFileTypeInterface = getFileTypeInterface;
function getRegisterNames(fileTypeName, sdsConnection) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield sdsConnection.PDClass.callOperation('IDlcFileType.getRegisterNames', [fileTypeName]);
        const sdsResponse = response;
        const errCode = sdsResponse.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
        if (errCode < 0) {
            const value = sdsResponse.getParameter(node_sds_1.ParameterNames.PARAMETER);
            throw new Error(value[0]);
        }
        const registerNames = sdsResponse.getParameter(node_sds_1.ParameterNames.PARAMETER);
        return registerNames.filter(r => r && r.length > 0);
    });
}
function getFolderNames(sdsConnection) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const folderNames = yield sdsConnection.CustomOperations.runScriptOnServer(`context.changeScriptUser(DlcGlobalOptions.getAttribute("StandardUser"));return JSON.stringify([...context.getFoldersByName("*")].map(f => f.Name));`);
            return JSON.parse(folderNames).filter(f => !f.startsWith("Dlc_"));
        }
        catch (err) {
            return [];
        }
    });
}
/**
 * Get field names of all file types and create a string that contains the
 * TypeScript definition file content for all file types
 *
 * @param sdsConnection
 * @param params empty
 */
function getFileTypesTSD(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            let output = '';
            let fileTypeMappings = '';
            let registerPerFileTypeMapping = '';
            let fileTypesDisj = '';
            sdsConnection.PDClass.callOperation('IDlcFileType.getFileTypeNames', []).then((returnValue) => {
                const response = returnValue;
                const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
                if (errCode < 0) {
                    const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                    return reject(value[0]);
                }
                const fileTypeNames = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                // some checks
                if (!fileTypeNames || fileTypeNames.length <= 0) {
                    return reject('IDlcFileType.getFileTypeNames returned empty result');
                }
                // first entry contains the error message that is read in node-sds
                fileTypeNames.splice(0, 1);
                // iterate over file types and get the interface with the field names
                return reduce(fileTypeNames, function (numFileTypes, fileTypeName) {
                    // get interface for file type 'fileTypeName'
                    return getFileTypeInterface(sdsConnection, [fileTypeName], connInfo).then((ftInterface) => {
                        // add interface of file type 'fileTypeName'
                        output += ftInterface[0];
                        // add 'fileTypeName' to file type mappings
                        if (fileTypeName.length > 0) {
                            fileTypeMappings += `\t"${fileTypeName}": ${fileTypeName};` + os.EOL;
                            fileTypesDisj += ` ${fileTypeName} |`;
                            registerPerFileTypeMapping += `\t"${fileTypeName}": ${fileTypeName}RegisterNames;${os.EOL}`;
                        }
                        // count the file types, not really needed for now
                        return numFileTypes + 1;
                    });
                }, 0).then((numFileTypes) => __awaiter(this, void 0, void 0, function* () {
                    // iteration finished, all available file types inserted
                    // add the file type mapper
                    // but only if file types have been inserted
                    if (output.length > 0) {
                        if (fileTypeMappings.length > 0) {
                            let fileTypeMapper = 'interface FileTypeMapper {' + os.EOL;
                            fileTypeMapper += fileTypeMappings;
                            fileTypeMapper += `}` + os.EOL;
                            fileTypeMapper += os.EOL;
                            output += fileTypeMapper + os.EOL;
                            // add interface FileTypeFieldsMapper
                            let fileTypeFieldsMapper = `interface FileTypeFieldsMapper {${os.EOL}`;
                            fileTypeFieldsMapper += fileTypeMappings.replace(/;(\r?\n)/g, "Fields;$1");
                            fileTypeFieldsMapper += `}${os.EOL}${os.EOL}`;
                            output += fileTypeFieldsMapper + os.EOL;
                            // remove the last ' |' from fileTypesDisj
                            let fileTypesType = 'declare type FileTypes =' + fileTypesDisj.slice(0, fileTypesDisj.length - 2) + ';';
                            output += fileTypesType + os.EOL;
                        }
                        output += `interface RegisterPerFileTypeMapper {${os.EOL}${registerPerFileTypeMapping}}${os.EOL}`;
                    }
                    const folderNames = yield getFolderNames(sdsConnection);
                    if (folderNames.length > 0) {
                        output += `${os.EOL}declare type FolderNames = "${folderNames.join("\" | \"")}";${os.EOL}`;
                    }
                    // output contains the whole d.ts string now
                    resolve([output]);
                })).catch((error) => {
                    reject(error);
                });
            }).catch((reason) => {
                reject('getFieldNames failed: ' + reason);
            });
        });
    });
}
exports.getFileTypesTSD = getFileTypesTSD;
/**
 * Set script parameters
 *
 * @param sdsConnection
 * @param params
 */
function setScriptInfoFromJSON(sdsConnection, params) {
    return new Promise((resolve, reject) => {
        sdsConnection.PDClass.callOperation('PortalScript.setScriptInfoFromJSON', params).then((returnValue) => {
            const response = returnValue;
            const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
            if (errCode < 0) {
                const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                return reject(value[0]);
            }
            resolve();
        }).catch((reason) => {
            reject('setScriptParameters failed: ' + reason);
        });
    });
}
function getScriptInfoAsJSON(sdsConnection, scripts) {
    return new Promise((resolve, reject) => {
        const script = scripts[0];
        sdsConnection.PDClass.callOperation('PortalScript.getScriptInfoAsJSON', [script.name]).then((returnValue) => {
            const response = returnValue;
            const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
            if (errCode < 0) {
                const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                return reject(value[0]);
            }
            const param = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
            const err = param[0];
            if (0 < err.length) {
                reject(err);
            }
            else if (1 < param.length) {
                let json = param[1];
                script.parameters = json;
                resolve([json]);
            }
        }).catch((error) => {
            reject(error);
        });
    });
}
function getScriptInfoAsJSONAll(sdsConnection, params) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            let jsonOut = [];
            return reduce(params, function (numScripts, _script) {
                return getScriptInfoAsJSON(sdsConnection, [_script]).then((value) => {
                    const jsonScript = value[0];
                    jsonOut.push(_script.name);
                    jsonOut.push(jsonScript);
                    return numScripts + 1;
                });
            }, 0).then((numScripts) => {
                resolve(jsonOut);
            }).catch((error) => {
                reject(error);
            });
        });
    });
}
exports.getScriptInfoAsJSONAll = getScriptInfoAsJSONAll;
function getSystemUser(sdsConnection, params) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            sdsConnection.PDClass.callOperation('Systemuser.get', ['test']).then((returnValue) => {
                const response = returnValue;
                const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
                if (errCode < 0) {
                    const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                    return reject(value[0]);
                }
                resolve([]);
            }).catch((reason) => {
                reject('getSystemUser failed: ' + reason);
            });
        });
    });
}
exports.getSystemUser = getSystemUser;
/**
 * Download script.
 *
 * @param sdsConnection
 * @param params
 */
function downloadScript(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            if (0 === params.length) {
                resolve([]);
            }
            else {
                let script = params[0];
                sdsConnection.PDClass.callOperation('PortalScript.downloadScript', [script.name]).then((returnValue) => {
                    const response = returnValue;
                    const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
                    if (errCode < 0) {
                        const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                        return reject(value[0]);
                    }
                    const retval = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                    if (!retval[0] || typeof (retval[0]) !== 'string') {
                        return reject('could not find ' + script.name + ' on server');
                    }
                    if ('false' === retval[1] || 'decrypted' === retval[1] || ('true' === retval[1] && script.allowDownloadEncrypted)) {
                        script.serverCode = ensureNoBOM(retval[0]);
                        script.encrypted = retval[1];
                        let scriptPath;
                        // script category
                        if (checkVersion(connInfo, exports.VERSION_CATEGORIES, "VERSION_CATEGORIES") && retval[2] && retval[2].length > 0)
                            script.category = retval[2];
                        // script mode
                        if (checkVersion(connInfo, exports.VERSION_MODULE_SCRIPT, "VERSION_MODULE_SCRIPT") && retval[3] && (retval[3] === "Classic" || retval[3] === "Module"))
                            script.mode = retval[3];
                        // script parameters
                        if (!script.downloadParameters)
                            return resolve([script]);
                        if (!checkVersion(connInfo, exports.VERSION_PARAMS_GET, "VERSION_PARAMS_DOWN"))
                            return resolve([script]);
                        // get parameters as JSON
                        getScriptInfoAsJSON(sdsConnection, [script]).then(() => {
                            console.log(`${script.name} uploaded and parameters set`);
                            resolve([script]);
                        }).catch((reason) => {
                            console.log(`${script.name} uploaded but parameters not set`);
                            // todo warning
                            resolve([script]);
                        });
                    }
                    else if ('true' === retval[1]) {
                        reject(new Error(ERROR_DECRYPT_PERMISSION));
                    }
                    else {
                        reject('Unexpected error in downloadScript');
                    }
                }).catch((reason) => {
                    reject(reason);
                });
            }
        });
    });
}
exports.downloadScript = downloadScript;
/**
 * Download all scripts from given list.
 *
 * @return Array containing all downloaded scripts, including the source-code.
 * @param sdsConnection
 * @param params Array containing all scripts to download.
 */
function downloadAll(sdsConnection, scripts, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            let returnScripts = [];
            if (0 === scripts.length) {
                resolve(returnScripts);
            }
            else {
                return reduce(scripts, function (numScripts, script) {
                    return downloadScript(sdsConnection, [script], connInfo).then((retval) => {
                        const currentScript = retval[0];
                        returnScripts.push(currentScript);
                        return numScripts + 1;
                    }).catch((error) => {
                        console.log('downloadScript -> catch ' + error.message);
                        return numScripts;
                    });
                }, 0).then((numScripts) => {
                    resolve(returnScripts);
                }).catch((error) => {
                    reject(error);
                });
            }
        });
    });
}
exports.downloadAll = downloadAll;
/**
 * To upload a script correctly to a version lower than 8040, 'script.encrypted' must be set.
 * And then the behaviour of the versions 8040 and higher should be imitated, depending on
 * script.encrypted (see documentation of that member).
 * The script is downloaded to get information of the state of the server script.
 */
function encryptionWorkaround(sdsConnection, params, connInfo) {
    return new Promise((resolve, reject) => {
        if (connInfo && checkVersion(connInfo, exports.VERSION_ENCRYPTION)) {
            return resolve();
        }
        if (0 === params.length) {
            return reject('Empty paramter in checkVersionEncryption');
        }
        let script = params[0];
        if (script.encrypted === 'decrypted') {
            return resolve();
        }
        if (script.encrypted === 'forceFalse') {
            script.encrypted = 'false';
            return resolve();
        }
        // script.encrypted === 'false' is default:
        // script must be encrypted, if it's encrypted on server or contains // #crypt
        sdsConnection.PDClass.callOperation('PortalScript.downloadScript', [script.name]).then((returnValue) => {
            const response = returnValue;
            const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
            if (errCode < 0) {
                const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                return reject(value[0]);
            }
            const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
            if (!value || value.length === 0) {
                // script not on server
                return resolve();
            }
            if (value.length < 2) {
                return reject(`Unexpected return value length (${value.length}) in checkVersionEncryption on DOCUMENTS #${connInfo.documentsVersion}`);
            }
            if (value[1] === 'true' || value[1] === 'decrypted') {
                script.encrypted = 'decrypted';
                return resolve();
            }
            if (value[1] === 'false') {
                if (script.localCode && script.localCode.indexOf('// #crypt') >= 0) {
                    script.encrypted = 'decrypted';
                }
                else {
                    script.encrypted = 'false';
                }
                return resolve();
            }
            return reject(`Unexpected return value (${value}) in checkVersionEncryption on DOCUMENTS #${connInfo.documentsVersion}`);
        }).catch((reason) => {
            reject(reason);
        });
    });
}
/**
 * If the given script can be uploaded, an empty list is returned.
 * If not, a script containing the server source code and the server
 * encrypt state is returned.
 * Both cases are resolved. Reject only in case of error.
 *
 * @param sdsConnection
 * @param params
 */
function checkForConflict(sdsConnection, params) {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        if (0 === params.length) {
            return resolve([]);
        }
        let script = params[0];
        if (!script.conflictMode || script.forceUpload) {
            return resolve([script]);
        }
        const response = yield sdsConnection.PDClass.callOperation('PortalScript.downloadScript', [script.name]);
        const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
        if (errCode < 0) {
            const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
            return reject(value[0]);
        }
        const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
        if (!value || value.length === 0) {
            // script not on server
            script.conflict |= exports.CONFLICT_SOURCE_CODE;
            return resolve([script]);
        }
        if (value.length < 2) {
            return reject('Unexpected error in checkForConflict');
        }
        if (value && 'true' === value[1]) {
            // script encrypted on server and no decryption pem available
            script.conflict |= exports.CONFLICT_SOURCE_CODE;
            script.encrypted = value[1];
        }
        else {
            // get hash value from server script code
            const serverCode = ensureNoBOM(value[0]);
            let serverHash = crypto.createHash('md5').update(serverCode || '').digest('hex');
            // compare hash value
            if (script.lastSyncHash !== serverHash) {
                // server code has been changed
                script.conflict |= exports.CONFLICT_SOURCE_CODE;
                script.serverCode = serverCode;
            }
        }
        // compare category
        if (value[2] && value[2] !== script.category) {
            script.conflict |= exports.CONFLICT_CATEGORY;
        }
        return resolve([script]);
    }));
}
/**
 * Uploads a script
 * @param sdsConnection
 * @param inputScript Script to be uploaded, in an array (todo)
 * @param connInfo
 * @returns inputScript in an array (todo) if it was either uploaded or had a conflict, empty array if input was empty
 */
function uploadScript(sdsConnection, inputScript, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (inputScript.length === 0) {
                    return resolve([]);
                }
                const script = inputScript[0];
                // versions < 8040: problems with encryption!
                yield encryptionWorkaround(sdsConnection, [script], connInfo);
                script.localCode = ensureNoBOM(script.localCode);
                if (!script.localCode) {
                    return reject(ERROR_SOURCE_MISSING);
                }
                // conflict?
                const conflictValue = yield checkForConflict(sdsConnection, [script]);
                const conflictScript = conflictValue[0];
                if (conflictScript && conflictScript.conflict)
                    return resolve([conflictScript]);
                // uploadScript params
                if (!script.encrypted)
                    script.encrypted = 'false';
                let paramCategory = '';
                if (checkVersion(connInfo, exports.VERSION_CATEGORIES, "VERSION_CATEGORIES") && script.category)
                    paramCategory = script.category;
                let paramMode = "";
                if (checkVersion(connInfo, exports.VERSION_MODULE_SCRIPT, "VERSION_MODULE_SCRIPT"))
                    paramMode = script.mode;
                const uploadParams = [script.name, script.localCode, script.encrypted, paramCategory, paramMode];
                // uplad script
                const response = yield sdsConnection.PDClass.callOperation("PortalScript.uploadScript", uploadParams);
                const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
                if (errCode < 0) {
                    const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                    return reject(value[0]);
                }
                // old versions do not return a value
                // const value = response.getParameter(ParameterNames.PARAMETER) as string[];
                // set hash value
                if (script.conflictMode) {
                    script.lastSyncHash = crypto.createHash('md5').update(script.localCode).digest("hex");
                }
                // script parameters
                if (!script.parameters || script.parameters.length === 0) {
                    return resolve([script]);
                }
                if (!checkVersion(connInfo, exports.VERSION_PARAMS_SET, "VERSION_PARAMS_UP")) {
                    return resolve([script]);
                }
                let scriptParameters = [script.name, script.parameters];
                yield setScriptInfoFromJSON(sdsConnection, scriptParameters);
                return resolve([script]);
            }
            catch (reason) {
                return reject(reason);
            }
        }));
    });
}
exports.uploadScript = uploadScript;
/**
 * Uploads scripts from given list.
 * @param sdsConnection
 * @param inputScripts List of scripts to be uploaded
 * @param connInfo
 * @returns List of scripts, containing scripts from inputScripts that were either uploaded or had a conflict, empty array if input was empty
 */
function uploadScripts(sdsConnection, inputScripts, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            if (!connInfo) {
                return reject('login information missing');
            }
            if (0 === inputScripts.length) {
                return resolve([]);
            }
            let returnScripts = [];
            for (const inputScript of inputScripts) {
                let retVal = [];
                try {
                    retVal = yield uploadScript(sdsConnection, [inputScript], connInfo);
                }
                catch (err) {
                    if (err === ERROR_SOURCE_MISSING && inputScripts.length > 1) {
                        // script could not be uploaded, try to upload the others
                    }
                    else {
                        return reject(err);
                    }
                }
                if (retVal && retVal.length === 1) {
                    // script uploaded, or conflict flag set
                    returnScripts.push(inputScript);
                }
            }
            return resolve(returnScripts);
        }));
    });
}
exports.uploadScripts = uploadScripts;
/**
 * Run script.
 *
 * @param sdsConnection
 * @param params
 */
function runScript(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            if (0 === params.length) {
                resolve([]);
            }
            else {
                let script = params[0];
                sdsConnection.PDClass.callOperation('PortalScript.runScript', [script.name]).then((returnValue) => {
                    const response = returnValue;
                    const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
                    if (errCode < 0) {
                        // no error!
                        // bug in runScript and debugScript on Documents:
                        // if the script returns a value, RETURN_VALUE is set to -1
                        // const value = response.getParameter(ParameterNames.PARAMETER) as string[];
                        // return reject(value[0]);
                    }
                    const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                    if (!value || 0 === value.length) {
                        reject('could not find ' + params[0] + ' on server');
                    }
                    else {
                        script.output = value.join(os.EOL);
                        resolve([script]);
                    }
                }).catch((reason) => {
                    reject(reason);
                });
            }
        });
    });
}
exports.runScript = runScript;
/**
 * Run script.
 *
 * @param sdsConnection
 * @param params
 */
function debugScript(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            if (0 === params.length) {
                resolve([]);
            }
            else {
                let script = params[0];
                sdsConnection.PDClass.callOperation('PortalScript.debugScript', [script.name]).then((returnValue) => {
                    const response = returnValue;
                    const errCode = response.getParameter(node_sds_1.ParameterNames.RETURN_VALUE);
                    if (errCode < 0) {
                        // no error!
                        // bug in runScript and debugScript on Documents:
                        // if the script returns a value, RETURN_VALUE is set to -1
                        // const value = response.getParameter(ParameterNames.PARAMETER) as string[];
                        // return reject(value[0]);
                    }
                    const value = response.getParameter(node_sds_1.ParameterNames.PARAMETER);
                    if (!value || 0 === value.length) {
                        reject('could not find ' + params[0] + ' on server');
                    }
                    else {
                        script.output = value.join(os.EOL);
                        resolve([script]);
                    }
                }).catch((reason) => {
                    reject(reason);
                });
            }
        });
    });
}
exports.debugScript = debugScript;
/**
 * Execute all scripts in given list on server.
 *
 * @return Array containing all executed scripts, including the output.
 * @param sdsConnection
 * @param params Array containing all scripts to execute.
 */
function runAll(sdsConnection, params, connInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            let scripts = [];
            return reduce(params, function (numScripts, _script) {
                return runScript(sdsConnection, [_script], connInfo).then((value) => {
                    let script = value[0];
                    scripts.push(script);
                    return numScripts + 1;
                });
            }, 0).then((numScripts) => {
                resolve(scripts);
            }).catch((error) => {
                reject(error);
            });
        });
    });
}
exports.runAll = runAll;
/**
 * Helper functions - no server call
 *
 *
 * The following functions are only some additional helper functions.
 * They don't do any call on server.
 */
/**
 *
 * @param data
 * @param filename
 * @param allowSubFolder
 */
function writeFileEnsureDir(data, filename) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            if (!filename || filename.length === 0)
                return resolve(false);
            const folder = path.dirname(filename);
            if (!folder)
                return reject(`Error in filename ${filename}`);
            fs.ensureDir(folder, function (error) {
                if (error) {
                    reject(error);
                }
                else {
                    fs.writeFile(filename, data, { encoding: 'utf8' }, function (error) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve(true);
                        }
                    });
                }
            });
        });
    });
}
exports.writeFileEnsureDir = writeFileEnsureDir;
function saveScriptUpdateSyncHash(scripts) {
    return __awaiter(this, void 0, void 0, function* () {
        let numscripts = 0;
        for (const script of scripts) {
            // if script.path is not set, script will not be saved in writeFileEnsureDir(),
            // so the path member can be used to prevent single scripts of the scripts-array
            // from being saved
            if (script.path && script.mode === 'Module')
                script.path = script.path.replace(/\.js$/, '.mjs');
            const saved = yield writeFileEnsureDir(script.serverCode, script.path);
            script.localCode = script.serverCode;
            if (script.conflictMode)
                script.lastSyncHash = crypto.createHash('md5').update(script.localCode || '').digest('hex');
            numscripts += saved ? 1 : 0;
        }
        return numscripts;
    });
}
exports.saveScriptUpdateSyncHash = saveScriptUpdateSyncHash;
/**
 * Returns a list of files inside a directory
 * @param dir - directory path
 * @param [rec=true] - Specifies wether to read the directory recursive
 * @returns List of files
 */
function readDirSync(dir, rec = true) {
    let results = [];
    let list = fs.readdirSync(dir);
    for (let elem of list) { // for-of loops are easier to debug
        elem = path.join(dir, elem);
        const stats = fs.lstatSync(elem);
        if (stats.isSymbolicLink()) {
            // returns the path where the symlink points to
            elem = fs.readlinkSync(elem);
        }
        if (fs.existsSync(elem)) {
            if (fs.statSync(elem).isFile()) {
                results.push(elem);
            }
            else if (rec) {
                results = results.concat(readDirSync(elem, rec));
            }
        }
    }
    return results;
}
exports.readDirSync = readDirSync;
/**
 * Returns a list of scripts inside a directory
 * @param dir - directory path
 * @param [subfolders=true] - Specifies wether to read the directory recursive
 * @returns List of scripts
 */
function getScriptsFromFolderSync(dir, subfolders = true) {
    let scripts = [];
    const filepaths = readDirSync(dir, subfolders);
    // resolve file paths to scriptT-objects
    filepaths.forEach((file) => {
        if (fs.existsSync(file) && path.extname(file).match(/\.m?js$/) !== null) {
            const scriptName = path.parse(file).name;
            const duplicate = scripts.find(s => s.name === scriptName);
            const newScript = new scriptT(scriptName, file, fs.readFileSync(file).toString());
            if (duplicate) {
                duplicate.duplicate = true;
                newScript.duplicate = true;
            }
            scripts.push(newScript);
        }
    });
    return scripts;
}
exports.getScriptsFromFolderSync = getScriptsFromFolderSync;
function convertDocumentsFieldType(documentsType) {
    switch (documentsType) {
        case 'Checkbox':
        case 'Bool':
            return 'boolean';
        case 'Numeric':
            return 'number';
        case 'Date':
        case 'Timestamp':
            return 'Date | null';
        case 'String':
        case 'Text':
        case 'Text (Fixed Font)':
        case 'Filing plan':
        case 'E-Mail':
        case 'URL':
        case 'HTML':
        case 'Reference':
        case 'Gadget':
        case 'Enumeration':
        case 'Double select list':
        case 'Custom':
            return 'string';
        default:
            return 'any';
    }
}
function checkVersion(loginData, version, warning) {
    if (Number(loginData.documentsVersion) >= Number(version)) {
        return true;
    }
    else {
        if ("VERSION_CATEGORIES" === warning) {
            loginData.lastWarning = `For using category features DOCUMENTS ${exports.VERSION_CATEGORIES} is required`;
        }
        else if ("VERSION_PARAMS_SET" === warning) {
            loginData.lastWarning = `For uploading parameter DOCUMENTS ${exports.VERSION_PARAMS_SET} is required`;
        }
        else if ("VERSION_PARAMS_GET" === warning) {
            loginData.lastWarning = `For downloading parameter DOCUMENTS ${exports.VERSION_PARAMS_GET} is required`;
        }
        return false;
    }
}
function ensureNoBOM(sourceCode) {
    if (!sourceCode) {
        return undefined;
    }
    return sourceCode.replace(/^\ufeff/, '');
}
//# sourceMappingURL=serverOperations.js.map