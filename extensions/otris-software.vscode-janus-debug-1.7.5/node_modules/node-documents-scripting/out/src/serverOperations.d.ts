import * as config from "./config";
import { SDSConnection } from "@otris/node-sds";
export declare const VERSION_MIN = "8034";
export declare const VERSION_PARAMS_GET = "8036";
export declare const VERSION_ENCRYPTION = "8040";
export declare const VERSION_CATEGORIES = "8041";
export declare const VERSION_FIELD_TYPES = "8044";
export declare const VERSION_PARAMS_SET = "8067";
export declare const VERSION_SHOW_IMPORTS = "8047";
export declare const VERSION_MODULE_SCRIPT = "8502";
export declare const CONFLICT_SOURCE_CODE = 1;
export declare const CONFLICT_CATEGORY = 2;
export declare class scriptT {
    /**
     * Name of the script without extension.
     * A script is always a javascript file.
     */
    name: string;
    path?: string;
    /**
     * The source code of the script.
     *
     * If serverCode is set after calling uploadScript, localCode contains the
     * local code of the script and serverCode the code on server.
     */
    localCode?: string;
    /**
     * Source code of the script on server.
     * Only set, if code on server has been changed after last synchronisation.
     */
    serverCode?: string;
    /**
     * Output of run script.
     */
    output?: string;
    /**
     * Encryption state of local and server script on upload/download.
     * Value can be true, decrypted, false or forceFalse
     *
     * true:
     * upload/download: local script and server script encrypted, not allowed
     *
     * decrypted:
     * upload: local script not encrypted, script encrypted on upload
     * download: server script encrypted, script decrypted on download
     *
     * false:
     * download: server script not encrypted, local script not encrypted
     * upload: local script not encrypted, script encrypted on upload, if
     * + server script is encrypted or
     * + local script contains // #crypt
     *
     * forceFalse:
     * upload: local script not encrypted, server script not encrypted
     */
    encrypted?: string;
    /**
     * Internal flag.
     */
    allowDownloadEncrypted: boolean;
    /**
     * Default: true
     *
     * If the function 'uploadScript' is called with a script in conflict
     * mode, the hash value is used to check, if the source code of the
     * script on server has changed since last up- or download.
     *
     * If a script in conflict mode was changed on server, it won't
     * be uploaded, instead the member 'conflict' will be set to true.
     */
    conflictMode: boolean;
    /**
     * Hash value of the source code at the time of last synchronisation,
     * meaning at the time of last up- or download.
     * This value is only set if the script is in conflict mode.
     */
    lastSyncHash?: string;
    /**
     * Bit pattern.
     *
     * CONFLICT_SOURCE_CODE is set, if uploadScript was called for this script,
     * but the source code of the script on server has been changed since
     * last up- or download.
     *
     * CONFLICT_CATEGORY is set, if uploadScript was called for this script,
     * but the category is different on server.
     */
    conflict: number;
    /**
     * If this member is set to true, the script will be uploaded, even if
     * it's in conflict mode and the source code was changed on server.
     */
    forceUpload?: boolean;
    /**
     * The category of the script on server.
     */
    category?: string;
    /**
     * Set to true, if the category member should be set after the script is downloaded.
     * Only for version check. If this is set to true, and the version is to old, a
     * warning is set.
     */
    getCategories?: boolean;
    /**
     * json string describing the parameters
     */
    parameters?: string;
    /**
     * Set to true, if the user wants to download the parameters
     * when a script is downloaded.
     */
    downloadParameters?: boolean;
    duplicate?: boolean;
    mode: string;
    constructor(name: string, path?: string, localCode?: string);
}
export declare class xmlExport {
    className: string;
    filter: string;
    fileName: string;
    content?: string | undefined;
    files?: string[] | undefined;
    constructor(className: string, filter: string, fileName: string, content?: string | undefined, files?: string[] | undefined);
}
export type serverOperationT = (sdsConn: SDSConnection, param: any[], connInfo: config.ConnectionInformation) => Promise<any[]>;
/**
 * This function establishes a connection to the server, calls the given operation
 * and closes the connection. All available operations are implemented below.
 *
 * @param loginData
 * @param param input parameter of the operation
 * @param serverOperation the operation to be called on server
 */
export declare function serverSession(loginData: config.ConnectionInformation, param: any[], serverOperation?: serverOperationT): Promise<any[]>;
export declare function connectLogin(sdsConnection: SDSConnection | undefined, conn: config.Connection): Promise<SDSConnection>;
export declare function disconnect(sdsConnection: SDSConnection): void;
export declare function callClassOperation(sdsConnection: SDSConnection, op: string, params: string[]): Promise<string[]>;
export declare function getScriptMode(sdsConnection: SDSConnection, params: string[], connInfo: config.ConnectionInformation): Promise<string[]>;
export declare function setScriptMode(sdsConnection: SDSConnection, params: string[], connInfo: config.ConnectionInformation): Promise<string[]>;
export declare function getSourceCodeForEditor(sdsConnection: SDSConnection, params: string[], connInfo: config.ConnectionInformation): Promise<string[]>;
export declare function doMaintenance(sdsConnection: SDSConnection, params: string[]): Promise<string[]>;
/**
 * @param params if params[0] contains a number (e.g. "8034"), the version is checked against this number
 */
export declare function getDocumentsVersion(sdsConnection: SDSConnection, params: string[]): Promise<string[]>;
/**
 * @param params e.g. ["allowDecryption"] shows if user has permission to decrypt scripts (returns ["1"] for true)
 */
export declare function getProperty(sdsConnection: SDSConnection, params: string[], connInfo: config.ConnectionInformation): Promise<string[]>;
export declare function clearPortalScriptCache(sdsConnection: SDSConnection, params: string[], connInfo: config.ConnectionInformation): Promise<string[]>;
/**
 * @returns string[]: [json, msg, oid1, attr1, local1 (rel), oid2, ...]
 */
export declare function importXML(sdsConnection: SDSConnection, params: string[]): Promise<string[]>;
/**
 * Generate xml for filetypes or portal scripts
 * Some examples for params:
 * ["DlcFileType", "Title='crmNote'"],
 * ["PortalScript", "Name='myScript'"],
 * ["DlcFileType", ""],
 * ["PortalScript", ""]
 * ["DlcFileType", "(Title='crmNote'||Title='crmCase')"]
 *
 * @param params string array with two entries, class name and filter. See examples in description.
 * @return string array, first element is the xml as string, second to n-th value is the paths to the blobs
 */
export declare function exportXML(sdsConnection: SDSConnection, params: xmlExport[]): Promise<string[]>;
/**
 * @param files string array containing file paths, like [local1, remote1, ...]
 */
export declare function receiveFiles(sdsConnection: SDSConnection, files: string[]): Promise<string[]>;
/**
 * @param param [oid1, attr1, local1 (abs), oid2, ...]
 */
export declare function updateDocuments(sdsConnection: SDSConnection, param: string[]): Promise<string[]>;
/**
 * Load scripts to scriptlibs folder and make server using them by clearing cache
 */
export declare function updateScriptLibs(sdsConnection: SDSConnection, param: string[]): Promise<string[]>;
/**
 * Get all script names on server as scripts.
 *
 * @param sdsConnection
 * @param params category If set, script names from this category are returned.
 * @returns {scriptT[]} List of scripts created from all script names in category or all script names on server.
 */
export declare function getScriptsFromServer(sdsConnection: SDSConnection, params: string[], connInfo: config.ConnectionInformation): Promise<scriptT[]>;
/**
 * Get names of all scripts on server.
 *
 * @param sdsConnection
 * @param params category If set, script names from this category are returned.
 * @returns {string[]} List of script names from all scripts on server or in category.
 */
export declare function getScriptNamesFromServer(sdsConnection: SDSConnection, params: string[], connInfo: config.ConnectionInformation): Promise<string[]>;
/**
 * Get names and modes of all scripts on server.
 *
 * @param sdsConnection
 * @param params category If set, script names from this category are returned.
 * @returns {string[]} List of script names and modes from all scripts on server or in category.
 */
export declare function getScriptNamesWithModesFromServer(sdsConnection: SDSConnection, params: string[], connInfo: config.ConnectionInformation): Promise<string[]>;
/**
 * @param params empty for now, later: the categories
 * @return string array containing all filetype names
 */
export declare function getFileTypeNames(sdsConnection: SDSConnection, params: string[], connInfo: config.ConnectionInformation): Promise<string[]>;
/**
 * Get field names of a filetype and create interface declaration for TypeScript
 * definition file.
 *
 * @param sdsConnection
 * @param params the file type
 *
 * @return string containing the interface declaration for the file type
 */
export declare function getFileTypeInterface(sdsConnection: SDSConnection, params: string[], connInfo: config.ConnectionInformation): Promise<any[]>;
/**
 * Get field names of all file types and create a string that contains the
 * TypeScript definition file content for all file types
 *
 * @param sdsConnection
 * @param params empty
 */
export declare function getFileTypesTSD(sdsConnection: SDSConnection, params: string[], connInfo: config.ConnectionInformation): Promise<string[]>;
export declare function getScriptInfoAsJSONAll(sdsConnection: SDSConnection, params: scriptT[]): Promise<string[]>;
export declare function getSystemUser(sdsConnection: SDSConnection, params: any[]): Promise<any[]>;
/**
 * Download script.
 *
 * @param sdsConnection
 * @param params
 */
export declare function downloadScript(sdsConnection: SDSConnection, params: scriptT[], connInfo: config.ConnectionInformation): Promise<scriptT[]>;
/**
 * Download all scripts from given list.
 *
 * @return Array containing all downloaded scripts, including the source-code.
 * @param sdsConnection
 * @param params Array containing all scripts to download.
 */
export declare function downloadAll(sdsConnection: SDSConnection, scripts: scriptT[], connInfo: config.ConnectionInformation): Promise<scriptT[]>;
/**
 * Uploads a script
 * @param sdsConnection
 * @param inputScript Script to be uploaded, in an array (todo)
 * @param connInfo
 * @returns inputScript in an array (todo) if it was either uploaded or had a conflict, empty array if input was empty
 */
export declare function uploadScript(sdsConnection: SDSConnection, inputScript: scriptT[], connInfo: config.ConnectionInformation): Promise<scriptT[]>;
/**
 * Uploads scripts from given list.
 * @param sdsConnection
 * @param inputScripts List of scripts to be uploaded
 * @param connInfo
 * @returns List of scripts, containing scripts from inputScripts that were either uploaded or had a conflict, empty array if input was empty
 */
export declare function uploadScripts(sdsConnection: SDSConnection, inputScripts: scriptT[], connInfo: config.ConnectionInformation | undefined): Promise<scriptT[]>;
/**
 * Run script.
 *
 * @param sdsConnection
 * @param params
 */
export declare function runScript(sdsConnection: SDSConnection, params: scriptT[], connInfo: config.ConnectionInformation): Promise<scriptT[]>;
/**
 * Run script.
 *
 * @param sdsConnection
 * @param params
 */
export declare function debugScript(sdsConnection: SDSConnection, params: scriptT[], connInfo: config.ConnectionInformation): Promise<scriptT[]>;
/**
 * Execute all scripts in given list on server.
 *
 * @return Array containing all executed scripts, including the output.
 * @param sdsConnection
 * @param params Array containing all scripts to execute.
 */
export declare function runAll(sdsConnection: SDSConnection, params: scriptT[], connInfo: config.ConnectionInformation): Promise<scriptT[]>;
/**
 * Helper functions - no server call
 *
 *
 * The following functions are only some additional helper functions.
 * They don't do any call on server.
 */
/**
 *
 * @param data
 * @param filename
 * @param allowSubFolder
 */
export declare function writeFileEnsureDir(data: any, filename: string | undefined): Promise<boolean>;
export declare function saveScriptUpdateSyncHash(scripts: scriptT[]): Promise<number>;
/**
 * Returns a list of files inside a directory
 * @param dir - directory path
 * @param [rec=true] - Specifies wether to read the directory recursive
 * @returns List of files
 */
export declare function readDirSync(dir: string, rec?: boolean): string[];
/**
 * Returns a list of scripts inside a directory
 * @param dir - directory path
 * @param [subfolders=true] - Specifies wether to read the directory recursive
 * @returns List of scripts
 */
export declare function getScriptsFromFolderSync(dir: string, subfolders?: boolean): scriptT[];
